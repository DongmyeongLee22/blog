---
title: 클린 아키텍처
date: 2021-08-28 17:04
img: 
    - clean_architecture.jpeg
tags:
    - Design
---

우리는 어떻게 해야 미래에  어떤 변경을 흔히 하게 될지를 지금 알아내어, 이를 기초로 중요한 결정을 지금 구체적으로 내릴 수 있을까?

좋은 아키텍처를 만들기 위해서는 아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 더 가까움을 이해해야 한다.

### 일관된 소프트웨어 아키텍처 규칙
- 현재의 소프트웨어는 과거와 동일한 것들로 구성된다. 여전히 if 문, 할당문, 루프로 구성된다.
- 언어가 발전하고, 도구가 좋아져도 컴퓨터 프로그래밍을 이루는 기본 구성 요소는 조금도 바뀌지 않았다.
- **이것이 시스템의 종류와 관계없이 소프트웨어 아키텍처의 규칙이 일관된 이유다.**
- 이 책은 세월이 흘러도 변치 않는 규칙에 관한 것이다.

## 1. 설계와 아키텍처란?
- `아키텍처`는 저수준 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용된다.
- `설계(design)`는 저수준의 구조 또는 결정사항 등을 의미할 때가 많다.
- 하지만 이 둘은 별 차이가 없다. 저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소다.

### 좋은 설계와 나쁜 설계?
- **시스템을 만들고 유지보수하는데 투입되는 리소스를 시스템이 수명이 다할 때까지 낮게 유지할 수 있다면 좋은 설계**라고 할 수 있다.
- 새로운 시능을 출시할 때마다 비용이 증가한다면 나쁜 설계다.

### 소프트웨어 개발의 단순한 진리
- **빨리 가는 유일한 방법은 제대로 가는 것이다.**

## 2. 두 가지 가치에 대한 이야기
- 모든 소프트웨어 시스템은 이해관계자에게 서로 두 가지 가치를 제공하는데, `행위(behavior)`와 `구조(structure)`이다.

### 아이젠하워 매트릭스
- 긴급한 문제는 대체로 중요하지 않고, 중요한 문제는 절대로 긴급하지 않다. 이에 대한 우선순위를 매기면 다음과 같다.

```
1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지 않은
4. 긴급하지도 중요하지도 않은
```

- 소프트웨어의 첫 번쨰 가치인 `행위`는 **긴급하지만** 매번 높은 중요도를 가지지 않는다.
- 소프트웨어의 두 번째 가치인 `아키텍처`는 **중요하지만** 긴급한 경우는 절대 없다.
- 아키텍처는 우선순위의 2번째이고, 행위는 3번째이다. 관리자에게 아키텍처의 중요성을 설득하는 일은 개발팀에서 책임져야 한다.

## 3. SOLID
### 1) SRP(Single Responsibility Principle)
**단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.**
- 단순히 생각하면 해당 원칙은 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽지만, 그건 함수가 해야할 일이다.
- 여기서 `변경의 이유`는 변경을 요청하는 사용자나 이해관계자의 집단을 가리킨다. 이를 `액터(actor)`라고 부른다. 이를 통해 SRP를 다시 정의하면 아래와 같다.

**하나의 모듈은 오직 하나의 액터에 대해서만 책임을 져야 한다.**

### 2) OCP(Open-Closed Principle)
**소프트웨어 엔티티들(클래스, 함수, 모듈 등)은 확장에는 열려 있어야하고, 변경에는 닫혀 있어야 한다.**
- 소프트웨어 아키텍처를 공후하는 가장 근본적인 이유가 바로 이 떄문이다.
- OCP는 클래스와 모듈 수준에서도 도움이 되지만 아키텍처 컴포넌트 수준에서 훨씬 더 중요한 의미를 가진다.

#### 컴포넌트 분리
- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.
- 이를 위해서는 컴포넌트 단위를 분리하고, **저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있도록 의존성 계층구조가 만들어져야 한다.**
    - A의 변경에서 B를 보호하기 위해선 A가 B를 의존(A -> B)해야 한다.
    - 고수준 컴포넌트를 보호하기 위해선 저수준 컴포넌트가 고수준 컴포넌트에 의존할 수 있도록 해야 한다.
    
### 3) LSP(Liskov Substitution Principle)
**상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.**
- LSP를 위반하는 대표적인 예로 정사각형/직사각형 문제가 있다.
    - 직사각형은 높이와 너비가 독립적으로 변경되나, 정사각형은 반드시 함께 변경되어야 한다. 그러므로 정사각형은 직사각형의 하위 타입이 될 수 없다.
    
#### LSP와 아키텍처
- LSP는 상속뿐만 아니라 인터페이스와 구현체에서도 적용할 수 있다. 그리고 여기서의 인터페이스는 언어 레벨의 인터페이스 타입, API등이 될 수 있다.
- LSP 관점에서 인터페이스와 구현체는 상호 치환 가능하다고 기대한다. 인터페이스와 구현체가 상호 치환되지 않는다면 이러한 예외 사항을 처리해야한다.
    - 시스템에서 이런 예외 사항을 처리하기 위해 가장 간단한 방법은 하드코딩이다. 하드코딩은 유연하지 못하고 온갖 에러의 원인이 된다.
    - 이러한 예외 사항을 시스템에서 격리할 수 있어야 한다.

### 4) ISP(Interface Segregation Principle)
**클라이언트는 자신이 이용하지 않는 인터페이스에 의존하지 않아야 한다.**
- 아키텍처 관점에서도 이는 동일하다. 시스템이 이용하지 않는 모듈에 의존하게 되면 그 모듈의 변경이 시스템에 영향을 준다.

### 5) DIP(Dependency Inversion Principle)
**의존성은 세부 사항이 아니라 추상화에 의존해야 한다.**
- 이 원칙은 상대적으로 변경이 적은 안정적인 추상화에 의존하여 변경 가능성을 최소화함에 있다.
- 그러므로 변경될 일이 거의 없는 세부 사항인 구현체들에 의존하는 것은 문제가 되지 않는다.
    - java의 String과 같은 구체 클래스는 변경이 없고 매우 안정적이므로 DIP를 적용할 이유가 없다.
- **즉, 의존하지 않도록 피하고자 하는 것은 변경될 가능성이 큰 세부 사항들이다.**

#### 팩토리
- 모든 언어에서 객체를 생성하기 위해서는 결국 `구체 클래스(세부 사항)`에 의존해야 한다.
- 구체 클래스에 의존하지 않고 객체를 생성하기 위해 주로 `추상 팩토리`를 사용한다.
    - 추상 팩토리를 활용하면 구체 클래스를 생성하는 로직들을 캡슐화할 수 있다.

## 4. 컴포넌트 응집도
컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다. 자바의 경우 jar 파일이 컴포넌트라고 할 수 있다.

어떤 클래스를 어느 컴포넌트에 포함시킬지는 중요한 결정이고, 이런 컴포넌트 응집도와 관련된 세 가지 규칙이 있다.

### 1) REF: 재사용/릴리즈 등가 원칙(Reuse/Relase Equivalence Principle)
**재사용 단위를 릴리즈 단위와 같다.**
- 단일 컴포넌트는 응집성이 높은 클래스와 모듈들로 구성되어야 한다.
- 단일 컴포넌트에 묶인 클래스와 모듈들은 서로 공유하는 중요한 테마나 목적이 있어야 한다.

### 2) CCP: 공통 폐쇄 원칙(Common Closure Principle)
**동일한 이유로 동일한 시점에 변경되는 클래스는 같은 컴포넌트로 묶고, 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.**
- 컴포넌트 관점에서의 SRP에 대한 것으로 **단일 컴포넌트는 변경의 이유가 하나여야 한다.**
- 이 원칙을 지키면 어떠한 변경이 여러 컴포넌트가 아닌 단일 컴포넌트에서만 발생하므로 다른 컴포넌트에게 영향을 주지 않게 된다. 
 

### 3) CRP: 공통 재사용 원칙(Common Reues Principle)
**컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.** 
