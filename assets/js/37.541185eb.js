(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{534:function(a,e,t){"use strict";t.r(e);var r=t(31),_=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"write-consistency-levels"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#write-consistency-levels"}},[a._v("#")]),a._v(" Write consistency levels")]),a._v(" "),t("h3",{attrs:{id:"_1-all"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-all"}},[a._v("#")]),a._v(" 1. ALL")]),a._v(" "),t("ul",[t("li",[a._v("클러스터의 모든 replica 노드들의 "),t("code",[a._v("commit log")]),a._v("와 "),t("code",[a._v("memtable")]),a._v("에 쓰기 동작이 완료되어야 하는 level")]),a._v(" "),t("li",[a._v("가장 높은 일관성을 보장하지만 가용성은 가장 낮다.")])]),a._v(" "),t("h3",{attrs:{id:"_2-each-quorum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-each-quorum"}},[a._v("#")]),a._v(" 2. EACH_QUORUM")]),a._v(" "),t("ul",[t("li",[a._v("각 datacenter에서 "),t("code",[a._v("QUORUM")]),a._v("만큼의 replica 노드들의 "),t("code",[a._v("commit log")]),a._v("와 "),t("code",[a._v("memtable")]),a._v("에 쓰기 동작이 완료되어야 하는 level")]),a._v(" "),t("li",[a._v("특정 dc가 다운되면 QUORUM수를 만족하지 못해 쓰기 동작이 실패할 것이므로 각 datacenter를 같은 수준의 일관성으로 유지하고 싶을 때 사용할 수 있다.")])]),a._v(" "),t("h4",{attrs:{id:"데이터센터-datacenter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#데이터센터-datacenter"}},[a._v("#")]),a._v(" 데이터센터(datacenter)?")]),a._v(" "),t("ul",[t("li",[a._v("여기서 의미하는 datacenter는 특정 클러스터에서 "),t("code",[a._v("replication")]),a._v(", "),t("code",[a._v("workload segregation")]),a._v("을 목적으로 구성된 "),t("code",[a._v("노드들의 그룹")]),a._v("을 의미")]),a._v(" "),t("li",[a._v("흔히 아는 물리적 데이터 센터를 의미하는 것이 아님")]),a._v(" "),t("li",[t("a",{attrs:{href:"https://docs.datastax.com/en/glossary/doc/glossary/gloss_data_center.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("참고(datastax glossary)"),t("OutboundLink")],1)])]),a._v(" "),t("h4",{attrs:{id:"quorum-공식"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quorum-공식"}},[a._v("#")]),a._v(" QUORUM 공식")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("quorum = floor(sum of replication factors / 2) + 1")])]),a._v(" "),t("li",[t("code",[a._v("sum of replication factors = datacenter1_Replication Factors + dc2_RF + ... + dcN_RF")])])]),a._v(" "),t("p",[t("strong",[a._v("예시 1)")])]),a._v(" "),t("ul",[t("li",[a._v("replication factors = 3인 경우 quorm = 2가 되므로 1개의 노드가 다운되어도 정상 동작")])]),a._v(" "),t("p",[t("strong",[a._v("예시 2)")])]),a._v(" "),t("ul",[t("li",[a._v("datacenter가 2개 있고 각 dc의 replication factors = 3인 경우 quorm = 4가 되므로 2개의 노드가 다운되어도 정상 동작")])]),a._v(" "),t("blockquote",[t("p",[a._v("EACH_QUORUM의 경우 각 dc를 기준으로 하므로 dc1에서 1개, dc2에서 1개의 노드가 다운되었을 경우에만 정상 동작할 것이고 QUORUM은 dc1에서는 0개, dc2에서 2개의 노드가 다운되어도 정상 동작 할 것이다.")])]),a._v(" "),t("h3",{attrs:{id:"_3-quorum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-quorum"}},[a._v("#")]),a._v(" 3. QUORUM")]),a._v(" "),t("ul",[t("li",[a._v("모든 datacenter에서 "),t("code",[a._v("QUORUM")]),a._v("만큼의 replica 노드들의 "),t("code",[a._v("commit log")]),a._v("와 "),t("code",[a._v("memtable")]),a._v("에 쓰기 동작이 완료되어야 하는 level")])]),a._v(" "),t("h3",{attrs:{id:"_4-local-quorum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-local-quorum"}},[a._v("#")]),a._v(" 4. LOCAL_QUORUM")]),a._v(" "),t("ul",[t("li",[a._v("coordinator node가 존재하는 datacenter에서 "),t("code",[a._v("QUORUM")]),a._v("만큼의 replica 노드들의 "),t("code",[a._v("commit log")]),a._v("와 "),t("code",[a._v("memtable")]),a._v("에 쓰기 동작이 완료되어야 하는 level")]),a._v(" "),t("li",[a._v("multiple datacenter cluster에서 사용되며 하나의 dc에서 이루어지므로 dc간의 통신 지연을 방지할 수 있다.")])]),a._v(" "),t("h4",{attrs:{id:"coordinator-node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#coordinator-node"}},[a._v("#")]),a._v(" coordinator node")]),a._v(" "),t("ul",[t("li",[a._v("클러스터에서 어떤 노드들이 요청을 받아야 하는지 결정하는 노드")])]),a._v(" "),t("h3",{attrs:{id:"_5-one-two-three"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-one-two-three"}},[a._v("#")]),a._v(" 5. ONE, TWO, THREE")]),a._v(" "),t("ul",[t("li",[a._v("적어도 1(ONE) or 2(TWO) or 3(THREE)개의 replica 노드에 "),t("code",[a._v("commit log")]),a._v("와 "),t("code",[a._v("memtable")]),a._v("에 쓰기 동작이 완료되어야 하는 level")])]),a._v(" "),t("h3",{attrs:{id:"_6-local-one"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-local-one"}},[a._v("#")]),a._v(" 6. LOCAL_ONE")]),a._v(" "),t("ul",[t("li",[a._v("local datacenter에서 적어도 하나의 replica 노드에 "),t("code",[a._v("commit log")]),a._v("와 "),t("code",[a._v("memtable")]),a._v("에 쓰기 동작이 완료되어야 하는 level")])]),a._v(" "),t("h4",{attrs:{id:"one-vs-local-one"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#one-vs-local-one"}},[a._v("#")]),a._v(" ONE vs LOCAL_ONE")]),a._v(" "),t("ul",[t("li",[a._v("multiple datacenter에서 보통 ONE level이 적절하지만 각 dc간의 통신을 피하기 위해 LOCAL_ONE을 사용할 수 있다.")])]),a._v(" "),t("h3",{attrs:{id:"_7-any"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-any"}},[a._v("#")]),a._v(" 7. ANY")]),a._v(" "),t("ul",[t("li",[a._v("모든 replica 노드들이 다운되어도 쓰기 동작이 가능한 level")]),a._v(" "),t("li",[a._v("모든 replica 노드들이 다운되었다면 ANY 동작으로 쓰기가 성공한 데이터는 노드들이 회복될 때 까지 읽을 수 없다.")]),a._v(" "),t("li",[a._v("가장 높은 가용성을 보장하지만 일관성은 가장 낮다.")])]),a._v(" "),t("h2",{attrs:{id:"read-consistency-levels"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#read-consistency-levels"}},[a._v("#")]),a._v(" Read consistency levels")]),a._v(" "),t("h3",{attrs:{id:"_1-all-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-all-2"}},[a._v("#")]),a._v(" 1. ALL")]),a._v(" "),t("ul",[t("li",[a._v("모든 replica 노드들이 응답을 해야 값을 반환하는 level로 하나의 노드라도 응답하지 않으면 읽기 동작은 실패한다.")]),a._v(" "),t("li",[a._v("가장 높은 일관성을 보장하지만 가용성은 가장 낮다.")])]),a._v(" "),t("h3",{attrs:{id:"_2-each-quorum-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-each-quorum-2"}},[a._v("#")]),a._v(" 2. EACH_QUORUM")]),a._v(" "),t("ul",[t("li",[a._v("읽기에선 제공하지 않음")])]),a._v(" "),t("h3",{attrs:{id:"_3-quorum-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-quorum-2"}},[a._v("#")]),a._v(" 3. QUORUM")]),a._v(" "),t("ul",[t("li",[a._v("모든 datacenter에서 "),t("code",[a._v("QUORUM")]),a._v("만큼의 replica 노드들이 응답을 해야 값을 반환하는 level")])]),a._v(" "),t("h3",{attrs:{id:"_4-local-quorum-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-local-quorum-2"}},[a._v("#")]),a._v(" 4. LOCAL_QUORUM")]),a._v(" "),t("ul",[t("li",[a._v("coordinator node가 존재하는 datacenter에서 "),t("code",[a._v("QUORUM")]),a._v("만큼의 replica 노드들이 응답을 해야 값을 반환하는 level")]),a._v(" "),t("li",[a._v("multiple datacenter cluster에서 사용되며 하나의 dc에서 이루어지므로 dc간의 통신 지연을 방지할 수 있다.")])]),a._v(" "),t("h3",{attrs:{id:"_5-one-tow-three"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-one-tow-three"}},[a._v("#")]),a._v(" 5. ONE, TOW, THREE")]),a._v(" "),t("ul",[t("li",[a._v("가장 가까운 1(ONE) or 2(TWO) or 3(THREE)개의 replica 노드가 응답하는 경우 값을 반환하는 level")]),a._v(" "),t("li",[a._v("오래된 데이터를 읽어도 큰 문제가 없는 경우 가장 높은 가용성을 제공하는 level이다.")])]),a._v(" "),t("h3",{attrs:{id:"_6-local-one-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-local-one-2"}},[a._v("#")]),a._v(" 6. LOCAL_ONE")]),a._v(" "),t("ul",[t("li",[a._v("local datacenter에서 가장 가까운 하나의 replica 노드가 응답하는 경우 값을 반환하는 level")])]),a._v(" "),t("h3",{attrs:{id:"_7-serial"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-serial"}},[a._v("#")]),a._v(" 7. SERIAL")]),a._v(" "),t("ul",[t("li",[a._v("모든 datacenter에서 "),t("code",[a._v("QUORUM")]),a._v("만큼의 replica 노드에서 커밋 되지 않은 상태의 데이터를 읽을 수 있는 level")]),a._v(" "),t("li",[a._v("가장 최신의 값을 읽기 위해 사용할 수 있다.")])]),a._v(" "),t("h3",{attrs:{id:"_8-local-serial"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-local-serial"}},[a._v("#")]),a._v(" 8. LOCAL_SERIAL")]),a._v(" "),t("ul",[t("li",[a._v("SERIAL과 동일하나 local dc로 제한한다.")])]),a._v(" "),t("h2",{attrs:{id:"참고-자료"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#참고-자료"}},[a._v("#")]),a._v(" 참고 자료")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("datastax docs"),t("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=_.exports}}]);