(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{532:function(_,v,s){"use strict";s.r(v);var e=s(56),r=Object(e.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("p",[_._v("우리는 어떻게 해야 미래에  어떤 변경을 흔히 하게 될지를 지금 알아내어, 이를 기초로 중요한 결정을 지금 구체적으로 내릴 수 있을까?")]),_._v(" "),s("p",[_._v("좋은 아키텍처를 만들기 위해서는 아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 더 가까움을 이해해야 한다.")]),_._v(" "),s("h3",{attrs:{id:"일관된-소프트웨어-아키텍처-규칙"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#일관된-소프트웨어-아키텍처-규칙"}},[_._v("#")]),_._v(" 일관된 소프트웨어 아키텍처 규칙")]),_._v(" "),s("ul",[s("li",[_._v("현재의 소프트웨어는 과거와 동일한 것들로 구성된다. 여전히 if 문, 할당문, 루프로 구성된다.")]),_._v(" "),s("li",[_._v("언어가 발전하고, 도구가 좋아져도 컴퓨터 프로그래밍을 이루는 기본 구성 요소는 조금도 바뀌지 않았다.")]),_._v(" "),s("li",[s("strong",[_._v("이것이 시스템의 종류와 관계없이 소프트웨어 아키텍처의 규칙이 일관된 이유다.")])]),_._v(" "),s("li",[_._v("이 책은 세월이 흘러도 변치 않는 규칙에 관한 것이다.")])]),_._v(" "),s("h2",{attrs:{id:"_1-설계와-아키텍처란"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-설계와-아키텍처란"}},[_._v("#")]),_._v(" 1. 설계와 아키텍처란?")]),_._v(" "),s("ul",[s("li",[s("code",[_._v("아키텍처")]),_._v("는 저수준 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용된다.")]),_._v(" "),s("li",[s("code",[_._v("설계(design)")]),_._v("는 저수준의 구조 또는 결정사항 등을 의미할 때가 많다.")]),_._v(" "),s("li",[_._v("하지만 이 둘은 별 차이가 없다. 저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소다.")])]),_._v(" "),s("h3",{attrs:{id:"좋은-설계와-나쁜-설계"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#좋은-설계와-나쁜-설계"}},[_._v("#")]),_._v(" 좋은 설계와 나쁜 설계?")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("시스템을 만들고 유지보수하는데 투입되는 리소스를 시스템이 수명이 다할 때까지 낮게 유지할 수 있다면 좋은 설계")]),_._v("라고 할 수 있다.")]),_._v(" "),s("li",[_._v("새로운 시능을 출시할 때마다 비용이 증가한다면 나쁜 설계다.")])]),_._v(" "),s("h3",{attrs:{id:"소프트웨어-개발의-단순한-진리"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#소프트웨어-개발의-단순한-진리"}},[_._v("#")]),_._v(" 소프트웨어 개발의 단순한 진리")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("빨리 가는 유일한 방법은 제대로 가는 것이다.")])])]),_._v(" "),s("h2",{attrs:{id:"_2-두-가지-가치에-대한-이야기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-두-가지-가치에-대한-이야기"}},[_._v("#")]),_._v(" 2. 두 가지 가치에 대한 이야기")]),_._v(" "),s("ul",[s("li",[_._v("모든 소프트웨어 시스템은 이해관계자에게 서로 두 가지 가치를 제공하는데, "),s("code",[_._v("행위(behavior)")]),_._v("와 "),s("code",[_._v("구조(structure)")]),_._v("이다.")])]),_._v(" "),s("h3",{attrs:{id:"아이젠하워-매트릭스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#아이젠하워-매트릭스"}},[_._v("#")]),_._v(" 아이젠하워 매트릭스")]),_._v(" "),s("ul",[s("li",[_._v("긴급한 문제는 대체로 중요하지 않고, 중요한 문제는 절대로 긴급하지 않다. 이에 대한 우선순위를 매기면 다음과 같다.")])]),_._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("1. 긴급하고 중요한\n2. 긴급하지는 않지만 중요한\n3. 긴급하지만 중요하지 않은\n4. 긴급하지도 중요하지도 않은\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br")])]),s("ul",[s("li",[_._v("소프트웨어의 첫 번쨰 가치인 "),s("code",[_._v("행위")]),_._v("는 "),s("strong",[_._v("긴급하지만")]),_._v(" 매번 높은 중요도를 가지지 않는다.")]),_._v(" "),s("li",[_._v("소프트웨어의 두 번째 가치인 "),s("code",[_._v("아키텍처")]),_._v("는 "),s("strong",[_._v("중요하지만")]),_._v(" 긴급한 경우는 절대 없다.")]),_._v(" "),s("li",[_._v("아키텍처는 우선순위의 2번째이고, 행위는 3번째이다. 관리자에게 아키텍처의 중요성을 설득하는 일은 개발팀에서 책임져야 한다.")])]),_._v(" "),s("h2",{attrs:{id:"_3-solid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid"}},[_._v("#")]),_._v(" 3. SOLID")]),_._v(" "),s("h3",{attrs:{id:"_1-srp-single-responsibility-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-srp-single-responsibility-principle"}},[_._v("#")]),_._v(" 1) SRP(Single Responsibility Principle)")]),_._v(" "),s("p",[s("strong",[_._v("단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.")])]),_._v(" "),s("ul",[s("li",[_._v("단순히 생각하면 해당 원칙은 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽지만, 그건 함수가 해야할 일이다.")]),_._v(" "),s("li",[_._v("여기서 "),s("code",[_._v("변경의 이유")]),_._v("는 변경을 요청하는 사용자나 이해관계자의 집단을 가리킨다. 이를 "),s("code",[_._v("액터(actor)")]),_._v("라고 부른다. 이를 통해 SRP를 다시 정의하면 아래와 같다.")])]),_._v(" "),s("p",[s("strong",[_._v("하나의 모듈은 오직 하나의 액터에 대해서만 책임을 져야 한다.")])]),_._v(" "),s("h3",{attrs:{id:"_2-ocp-open-closed-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-ocp-open-closed-principle"}},[_._v("#")]),_._v(" 2) OCP(Open-Closed Principle)")]),_._v(" "),s("p",[s("strong",[_._v("소프트웨어 엔티티들(클래스, 함수, 모듈 등)은 확장에는 열려 있어야하고, 변경에는 닫혀 있어야 한다.")])]),_._v(" "),s("ul",[s("li",[_._v("소프트웨어 아키텍처를 공후하는 가장 근본적인 이유가 바로 이 떄문이다.")]),_._v(" "),s("li",[_._v("OCP는 클래스와 모듈 수준에서도 도움이 되지만 아키텍처 컴포넌트 수준에서 훨씬 더 중요한 의미를 가진다.")])]),_._v(" "),s("h4",{attrs:{id:"컴포넌트-분리"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#컴포넌트-분리"}},[_._v("#")]),_._v(" 컴포넌트 분리")]),_._v(" "),s("ul",[s("li",[_._v("OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.")]),_._v(" "),s("li",[_._v("이를 위해서는 컴포넌트 단위를 분리하고, "),s("strong",[_._v("저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있도록 의존성 계층구조가 만들어져야 한다.")]),_._v(" "),s("ul",[s("li",[_._v("A의 변경에서 B를 보호하기 위해선 A가 B를 의존(A -> B)해야 한다.")]),_._v(" "),s("li",[_._v("고수준 컴포넌트를 보호하기 위해선 저수준 컴포넌트가 고수준 컴포넌트에 의존할 수 있도록 해야 한다.")])])])]),_._v(" "),s("h3",{attrs:{id:"_3-lsp-liskov-substitution-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-lsp-liskov-substitution-principle"}},[_._v("#")]),_._v(" 3) LSP(Liskov Substitution Principle)")]),_._v(" "),s("p",[s("strong",[_._v("상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.")])]),_._v(" "),s("ul",[s("li",[_._v("LSP를 위반하는 대표적인 예로 정사각형/직사각형 문제가 있다.\n"),s("ul",[s("li",[_._v("직사각형은 높이와 너비가 독립적으로 변경되나, 정사각형은 반드시 함께 변경되어야 한다. 그러므로 정사각형은 직사각형의 하위 타입이 될 수 없다.")])])])]),_._v(" "),s("h4",{attrs:{id:"lsp와-아키텍처"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lsp와-아키텍처"}},[_._v("#")]),_._v(" LSP와 아키텍처")]),_._v(" "),s("ul",[s("li",[_._v("LSP는 상속뿐만 아니라 인터페이스와 구현체에서도 적용할 수 있다. 그리고 여기서의 인터페이스는 언어 레벨의 인터페이스 타입, API등이 될 수 있다.")]),_._v(" "),s("li",[_._v("LSP 관점에서 인터페이스와 구현체는 상호 치환 가능하다고 기대한다. 인터페이스와 구현체가 상호 치환되지 않는다면 이러한 예외 사항을 처리해야한다.\n"),s("ul",[s("li",[_._v("시스템에서 이런 예외 사항을 처리하기 위해 가장 간단한 방법은 하드코딩이다. 하드코딩은 유연하지 못하고 온갖 에러의 원인이 된다.")]),_._v(" "),s("li",[_._v("이러한 예외 사항을 시스템에서 격리할 수 있어야 한다.")])])])]),_._v(" "),s("h3",{attrs:{id:"_4-isp-interface-segregation-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-isp-interface-segregation-principle"}},[_._v("#")]),_._v(" 4) ISP(Interface Segregation Principle)")]),_._v(" "),s("p",[s("strong",[_._v("클라이언트는 자신이 이용하지 않는 인터페이스에 의존하지 않아야 한다.")])]),_._v(" "),s("ul",[s("li",[_._v("아키텍처 관점에서도 이는 동일하다. 시스템이 이용하지 않는 모듈에 의존하게 되면 그 모듈의 변경이 시스템에 영향을 준다.")])]),_._v(" "),s("h3",{attrs:{id:"_5-dip-dependency-inversion-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-dip-dependency-inversion-principle"}},[_._v("#")]),_._v(" 5) DIP(Dependency Inversion Principle)")]),_._v(" "),s("p",[s("strong",[_._v("의존성은 세부 사항이 아니라 추상화에 의존해야 한다.")])]),_._v(" "),s("ul",[s("li",[_._v("이 원칙은 상대적으로 변경이 적은 안정적인 추상화에 의존하여 변경 가능성을 최소화함에 있다.")]),_._v(" "),s("li",[_._v("그러므로 변경될 일이 거의 없는 세부 사항인 구현체들에 의존하는 것은 문제가 되지 않는다.\n"),s("ul",[s("li",[_._v("java의 String과 같은 구체 클래스는 변경이 없고 매우 안정적이므로 DIP를 적용할 이유가 없다.")])])]),_._v(" "),s("li",[s("strong",[_._v("즉, 의존하지 않도록 피하고자 하는 것은 변경될 가능성이 큰 세부 사항들이다.")])])]),_._v(" "),s("h4",{attrs:{id:"팩토리"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#팩토리"}},[_._v("#")]),_._v(" 팩토리")]),_._v(" "),s("ul",[s("li",[_._v("모든 언어에서 객체를 생성하기 위해서는 결국 "),s("code",[_._v("구체 클래스(세부 사항)")]),_._v("에 의존해야 한다.")]),_._v(" "),s("li",[_._v("구체 클래스에 의존하지 않고 객체를 생성하기 위해 주로 "),s("code",[_._v("추상 팩토리")]),_._v("를 사용한다.\n"),s("ul",[s("li",[_._v("추상 팩토리를 활용하면 구체 클래스를 생성하는 로직들을 캡슐화할 수 있다.")])])])]),_._v(" "),s("h2",{attrs:{id:"_4-컴포넌트-응집도"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-컴포넌트-응집도"}},[_._v("#")]),_._v(" 4. 컴포넌트 응집도")]),_._v(" "),s("p",[_._v("컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다. 자바의 경우 jar 파일이 컴포넌트라고 할 수 있다.")]),_._v(" "),s("p",[_._v("어떤 클래스를 어느 컴포넌트에 포함시킬지는 중요한 결정이고, 이런 컴포넌트 응집도와 관련된 세 가지 규칙이 있다.")]),_._v(" "),s("h3",{attrs:{id:"_1-ref-재사용-릴리즈-등가-원칙-reuse-relase-equivalence-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-ref-재사용-릴리즈-등가-원칙-reuse-relase-equivalence-principle"}},[_._v("#")]),_._v(" 1) REF: 재사용/릴리즈 등가 원칙(Reuse/Relase Equivalence Principle)")]),_._v(" "),s("p",[s("strong",[_._v("재사용 단위를 릴리즈 단위와 같다.")])]),_._v(" "),s("ul",[s("li",[_._v("단일 컴포넌트는 응집성이 높은 클래스와 모듈들로 구성되어야 한다.")]),_._v(" "),s("li",[_._v("단일 컴포넌트에 묶인 클래스와 모듈들은 서로 공유하는 중요한 테마나 목적이 있어야 한다.")])]),_._v(" "),s("h3",{attrs:{id:"_2-ccp-공통-폐쇄-원칙-common-closure-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-ccp-공통-폐쇄-원칙-common-closure-principle"}},[_._v("#")]),_._v(" 2) CCP: 공통 폐쇄 원칙(Common Closure Principle)")]),_._v(" "),s("p",[s("strong",[_._v("동일한 이유로 동일한 시점에 변경되는 클래스는 같은 컴포넌트로 묶고, 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.")])]),_._v(" "),s("ul",[s("li",[_._v("컴포넌트 관점에서의 SRP에 대한 것으로 "),s("strong",[_._v("단일 컴포넌트는 변경의 이유가 하나여야 한다.")])]),_._v(" "),s("li",[_._v("이 원칙을 지키면 어떠한 변경이 여러 컴포넌트가 아닌 단일 컴포넌트에서만 발생하므로 다른 컴포넌트에게 영향을 주지 않게 된다.")])]),_._v(" "),s("h3",{attrs:{id:"_3-crp-공통-재사용-원칙-common-reues-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-crp-공통-재사용-원칙-common-reues-principle"}},[_._v("#")]),_._v(" 3) CRP: 공통 재사용 원칙(Common Reues Principle)")]),_._v(" "),s("p",[s("strong",[_._v("컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.")])])])}),[],!1,null,null,null);v.default=r.exports}}]);