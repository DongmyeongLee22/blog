(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{534:function(_,v,t){"use strict";t.r(v);var a=t(56),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.")]),_._v(" "),t("p",[_._v("트랜잭션을 쓰면 애플리케이션에서 오류 처리를 하기가 훨씬 단순해진다. 어떤 연산은 성공하고 어떤 연산은 실패하는 경우 처럼 부분적인 실패를 걱정할 필요가 없기 때문이다.")]),_._v(" "),t("h2",{attrs:{id:"acid"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#acid"}},[_._v("#")]),_._v(" ACID")]),_._v(" "),t("p",[_._v("트랜잭션이 제공하는 안전성 보장은 흔히 "),t("strong",[_._v("원자성(Atomicity)")]),_._v(", "),t("strong",[_._v("일관성(Consistency)")]),_._v(", "),t("strong",[_._v("격리성(Isolation)")]),_._v(", **지속성(Durability)**을 위미하는 약어인 "),t("code",[_._v("ACID")]),_._v("로 잘 알려져 있다.")]),_._v(" "),t("h3",{attrs:{id:"원자성-atomicity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#원자성-atomicity"}},[_._v("#")]),_._v(" 원자성(Atomicity)")]),_._v(" "),t("p",[_._v("여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶이고 트랜잭션은 "),t("code",[_._v("완료(커밋)")]),_._v("되거나 결함 발생 시 해당 트랜잭션의 모든 쓰기 작업이"),t("code",[_._v("중단(어보트)")]),_._v("되거나 둘 중 하나여야 한다.")]),_._v(" "),t("p",[t("strong",[_._v("오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력이 ACID의 원자성의 결정적인 특성이다.")])]),_._v(" "),t("h3",{attrs:{id:"일관성-consistency"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#일관성-consistency"}},[_._v("#")]),_._v(" 일관성(Consistency)")]),_._v(" "),t("p",[t("code",[_._v("일관성")]),_._v("이라는 단어는 여러 의미로 사용된다.")]),_._v(" "),t("ul",[t("li",[_._v("eventual consistency, strong consistency에서는 복제 시스템간의 데이터 동기화에 대한 것이다.")]),_._v(" "),t("li",[_._v("consistent hashing(일관성 해싱)에서는 시스템들의 재균형화를 위한 파티셔닝 방법이다.")]),_._v(" "),t("li",[_._v("CAP 정리에서의 Consistency는 선형성을 의미한다.(ch9 참고)")]),_._v(" "),t("li",[t("strong",[_._v("ACID에서의 Consistency는 트랜잭션이 완료될 때 데이터에 관한 "),t("code",[_._v("불변식")]),_._v("이 반드시 만족되어야 하는 특성을 의미한다.")])])]),_._v(" "),t("p",[t("strong",[_._v("ACID에서의 일관성은 애플리케이션의 "),t("code",[_._v("불변식")]),_._v(" 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션이 책임이다.")])]),_._v(" "),t("ul",[t("li",[_._v("유일성 조건 및 외래 키 조건과 같이 데이터베이스에서 확인할 수 있는 불변식이 존재하긴 하지만 이외의 불변식은 애플리케이션에서 정의하며 이 불변식을 데이터베이스에서 검증할 수 없다.")]),_._v(" "),t("li",[_._v("ACID에서 일관성만 유일하게 애플리케이션의 속성이며 나머지는 모두 데이터베이스 속성이다.")])]),_._v(" "),t("h3",{attrs:{id:"격리성-isolation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#격리성-isolation"}},[_._v("#")]),_._v(" 격리성(Isolation)")]),_._v(" "),t("p",[_._v("동시에 실행되는 트랜잭션은 서로 격리되어야 한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다.")]),_._v(" "),t("h3",{attrs:{id:"지속성-durability"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#지속성-durability"}},[_._v("#")]),_._v(" 지속성(Durability)")]),_._v(" "),t("p",[_._v("트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않고 지속되어야 한다.")]),_._v(" "),t("ul",[t("li",[_._v("지속석을 보장하기 위해서 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때 까지 기다려야 한다.")]),_._v(" "),t("li",[_._v("완벽한 지속성은 보장할 수 없다. 모든 하드디스크와 백업이 동시에 파괴되면 데이터베이스가 해줄 수 있는건 없다.")])]),_._v(" "),t("h3",{attrs:{id:"다중-객체-연산-트랜잭선"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#다중-객체-연산-트랜잭선"}},[_._v("#")]),_._v(" 다중 객체 연산(트랜잭선)")]),_._v(" "),t("p",[_._v("다중 객체 연산을 위해서는 읽기 및 쓰기 연산들이 동일한 트랜잭션에 속하는지 알아야하고 이를 위해 관계형 데이터베이스에서는 TCP 연결 기반으로 BEGIN TRANSACTION문, COMMIT문 등을 통해 확인한다.")]),_._v(" "),t("p",[t("strong",[_._v("반면 비관계형 데이터베이스는 구현의 복잡성과 매우 높은 가용성 및 성능을 위해 이런 방식을 지원하지 않는 경우가 많다.")])]),_._v(" "),t("h4",{attrs:{id:"다중-객체-트랜잭션의-필요성"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#다중-객체-트랜잭션의-필요성"}},[_._v("#")]),_._v(" 다중 객체 트랜잭션의 필요성")]),_._v(" "),t("ul",[t("li",[_._v("단일 객체 트랜잭션 만으로 충분한 사용 사례가 있지만 많은 경우에 다중 객체 트랜잭션이 필요하다.\n"),t("ol",[t("li",[_._v("서로 첨조하는 여러 레코드를 삽입할 때 참조 키는 항상 올라르고 최신 정보를 반영해야 한다.")]),_._v(" "),t("li",[_._v("비정규화된 여러 테이블의 데이터들을 한 번에 갱신해야 한다.")]),_._v(" "),t("li",[_._v("보조 색인이 있는 경우 값이 변경될 때 색인도 함께 갱신되어야 한다.")])])])]),_._v(" "),t("h3",{attrs:{id:"오류와-어보트-처리"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#오류와-어보트-처리"}},[_._v("#")]),_._v(" 오류와 어보트 처리")]),_._v(" "),t("p",[t("strong",[_._v("트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.")])]),_._v(" "),t("p",[_._v("어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이니만 완벽하지 않다.")]),_._v(" "),t("ul",[t("li",[_._v("트랜잭션이 실제론 커밋되었지만 네트워크 문제로 클라이언트는 실패했다고 생각하여 중복 처리가 될 수 있다.")]),_._v(" "),t("li",[_._v("오류가 과부하 때문이라면 재시도는 더 큰 문제를 만들 수 있다.")]),_._v(" "),t("li",[_._v("일시적인 오류(데드락, 네트워크 오류, 시스템 장애)만 가치있고 영구적인 오류(제약 조건 위반)는 재시도해도 소용이 없다.")])]),_._v(" "),t("h2",{attrs:{id:"완화된-격리-수준"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#완화된-격리-수준"}},[_._v("#")]),_._v(" 완화된 격리 수준")]),_._v(" "),t("p",[_._v("트랜잭션이 직렬적으로 실행되는 직렬성 격리는 성능 비용이 크기 때문에 많은 데이터베이스는 그 비용을 지불하려고 하지 않는다. 따라서 완화된 격리 수준을 사용하는 시스템들이 흔하다.")]),_._v(" "),t("p",[_._v("완화된 격리 수준은 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는다. 각 수준별 특성을 파악하여 애플리케이션에 적합한 격리 수준을 선택할 수 있게 하자.")]),_._v(" "),t("h3",{attrs:{id:"_1-커밋-후-읽기-read-committed"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-커밋-후-읽기-read-committed"}},[_._v("#")]),_._v(" 1. 커밋 후 읽기(read committed)")]),_._v(" "),t("p",[_._v("가장 기본적인 트랜잭션 격리 수준으로 다음 두 가지를 보장해준다.")]),_._v(" "),t("ol",[t("li",[_._v("데이터베이스에서 읽을 때 커밋된 데이터만 본다.("),t("code",[_._v("더티 읽기")]),_._v("가 없음)")]),_._v(" "),t("li",[_._v("데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.("),t("code",[_._v("더티 쓰기")]),_._v("가 없음)")])]),_._v(" "),t("h4",{attrs:{id:"더티-읽기-방지"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#더티-읽기-방지"}},[_._v("#")]),_._v(" 더티 읽기 방지")]),_._v(" "),t("ul",[t("li",[_._v("다른 트랜잭션에서 커밋되지 않은 데이터를 보는 경우를 "),t("code",[_._v("더티 읽기")]),_._v("라고 부른다.")]),_._v(" "),t("li",[_._v("커밋 후 읽기 격리 수준에서는 더티 읽기를 막아야 한다.")]),_._v(" "),t("li",[_._v("더티 읽기를 막는게 유용한 이유는 다음과 같다.\n"),t("ul",[t("li",[_._v("트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있게 된다.")]),_._v(" "),t("li",[_._v("트랜잭션이 어보트되면 롤백해야 하는데 더티 읽기가 생기면 실제로 커밋되지 않은 롤백된 데이터를 볼 수 있게 된다.")])])])]),_._v(" "),t("h4",{attrs:{id:"더티-쓰기-방지"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#더티-쓰기-방지"}},[_._v("#")]),_._v(" 더티 쓰기 방지")]),_._v(" "),t("ul",[t("li",[_._v("아직 커밋되지 않은 트랜잭션에서 쓴 데이터를 새로운 트랜잭션이 덮어 쓰는 경우를 "),t("code",[_._v("더티 쓰기")]),_._v("라고 한다.\n"),t("ul",[t("li",[_._v("보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때 까지 두번째 쓰기를 지연시킨다.")])])]),_._v(" "),t("li",[_._v("커밋 후 읽기 격리 수준에서는 터티 쓰기를 막아야 한다.")]),_._v(" "),t("li",[_._v("더티 쓰기를 막지 않으면 트랜잭션이 여러 객체를 갱신할 때 갱신 값들이 다른 트랜잭션과 뒤섞여 데이터에 문제가 발생할 수 있다.")])]),_._v(" "),t("h4",{attrs:{id:"커밋-후-읽기-구현"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#커밋-후-읽기-구현"}},[_._v("#")]),_._v(" 커밋 후 읽기 구현")]),_._v(" "),t("ul",[t("li",[_._v("더티 쓰기의 경우 가장 흔한 방법으로 로우 수준 잠금을 사용해 방지한다.\n"),t("ul",[t("li",[_._v("트랜잭션에서 로우(객체)를 변경하고 싶다면 잠금을 획득해야 하고 오직 한 트랜잭션만 어떤 주어진 객체에 대해 잠금을 보유할 수 있다.")])])]),_._v(" "),t("li",[_._v("더티 읽기는 잠금을 사용하면 응답 시간에 많은 영향을 주기 때문에 "),t("strong",[_._v("데이터베이스는 모든 객체에 대해 과거에 커밋된 값과 현재 트랜잭션에서 쓴 새로운 값을 모두 기억한다.")]),_._v(" "),t("ul",[t("li",[_._v("다른 트랜잭션은 현재 트랜잭션에서 커밋하기 전 까지는 과거에 커밋된 값을 읽게 된다.")])])])]),_._v(" "),t("h4",{attrs:{id:"커밋-후-읽기-에서는-막을-수-없는-비반복-읽기-nonrepeatable-read"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#커밋-후-읽기-에서는-막을-수-없는-비반복-읽기-nonrepeatable-read"}},[_._v("#")]),_._v(" 커밋 후 읽기 에서는 막을 수 없는 비반복 읽기(nonrepeatable read)")]),_._v(" "),t("ul",[t("li",[_._v("은행 계좌 A, B에 각각 500원 씩 있고 A -> B로 100원을 송금 할 때 송금 트랜잭션이 처리되고 있는 순간에 계좌 잔고를 보면 A는 400원, B는 500원으로 나와 총 900원이 있는 것 처럼 나올 것이다.")]),_._v(" "),t("li",[_._v("이런 현상을 비반복 읽기(읽기 스큐)라고 하며 커밋 후 읽기 에서는 이런 현상을 막을 수 없다.")]),_._v(" "),t("li",[_._v("시간이 지나 트랜잭션이 커밋되면 이런 현상은 사라지지만 이런 일시적인 비일관성도 감내할 수 없는 경우가 있다.(대표적으로 백업이 있다.)")])]),_._v(" "),t("h3",{attrs:{id:"_2-스냅숏-격리"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-스냅숏-격리"}},[_._v("#")]),_._v(" 2. 스냅숏 격리")]),_._v(" "),t("p",[_._v("스냅숏 격리는 비반복 읽기와 같은 문제를 해결할 수 있는 가장 흔한 해결책이다. 트랜잭션은 특정 시점에 고정된 데이터베이스의 일관된 스냅숏만을 볼 수 있다.")]),_._v(" "),t("p",[t("strong",[_._v("각 트랜잭션은 데이터베이스의 일관된 스냅숏으로 부터 읽는다.")]),_._v(" "),t("strong",[_._v("그러므로 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터만을 보게 된다.")])]),_._v(" "),t("p",[_._v("스냅숏 격리는 PostgreSQL, InnoDB 엔진 기반의 MySQL, Oracle 등에서 지원한다.")]),_._v(" "),t("h4",{attrs:{id:"스냅숏-격리-구현"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#스냅숏-격리-구현"}},[_._v("#")]),_._v(" 스냅숏 격리 구현")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("스냅숏 격리를 구현하기 위해서는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다.")])]),_._v(" "),t("li",[_._v("데이터베이스가 객체의 "),t("strong",[_._v("여러 버전을 함께 유지하는 기법을 다중 버전 동시성 제어(multi-version concurreny control, MVCC)라고 한다.")]),_._v(" "),t("ul",[t("li",[_._v("스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다.(커밋된 버전과 아직 커밋되지 않은 버전 2가지로 커밋 후 읽기 격리를 구현할 수 있다.)")])])]),_._v(" "),t("li",[_._v("트랜잭션 별로 고유한 트랜잭션 ID를 할당받고 트랜잭션이 데이터를 쓸 때 마다 해당 트랜잭션 ID와 버전별 객체가 기록되어 트랜잭션에 따라 특정 버전의 객체들을 읽을 수 있도록 한다.")])]),_._v(" "),t("h4",{attrs:{id:"반복-읽기-repeatable-read-스냅숏-격리"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#반복-읽기-repeatable-read-스냅숏-격리"}},[_._v("#")]),_._v(" 반복 읽기(repeatable read) = 스냅숏 격리")]),_._v(" "),t("ul",[t("li",[_._v("PostgreSQL, MySQL에서는 스냅숏 격리를 반복 읽기라고 한다.")])]),_._v(" "),t("h3",{attrs:{id:"갱신-손실-방지"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#갱신-손실-방지"}},[_._v("#")]),_._v(" 갱신 손실 방지")]),_._v(" "),t("p",[_._v("커밋 후 읽기와 스냅숏 격리는 주로 동시에 실행되는 쓰기 작업에서 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 보장과 관련된 것이다.")]),_._v(" "),t("p",[_._v("하지만 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌 상황들이 존재하며 가장 유명한 것이 "),t("strong",[_._v("갱신 손실(lost update) 문제이다.")])]),_._v(" "),t("ul",[t("li",[_._v("갱신 손실 문제는 카운터와 같이 값을 읽고 변경한 후 변경된 값을 다시 써야할 때(read-modify-write) 여러 트랜잭션이 동시에 해당 작업은 수행하는 경우 발생할 수 있다.")]),_._v(" "),t("li",[_._v("이 문제는 흔해서 다야한 해결책이 개발되었다.")])]),_._v(" "),t("h4",{attrs:{id:"_1-원자적-쓰기-연산"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-원자적-쓰기-연산"}},[_._v("#")]),_._v(" 1) 원자적 쓰기 연산")]),_._v(" "),t("ul",[t("li",[_._v("여러 데이터베이스에서 원자적 쓰기 연산을 제공하기 때문에 애플리케이션에서 read-modify-write 주기를 구현할 필요를 없애 준다.")]),_._v(" "),t("li",[t("code",[_._v("UPDATE counters SET value = value + 1 WHERE key = 'foo'")]),_._v(" 이 쿼리는 대부분의 관계형 데이터베이스에서 동시성 안전하다.")])]),_._v(" "),t("h4",{attrs:{id:"_2-명시적인-잠금"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-명시적인-잠금"}},[_._v("#")]),_._v(" 2) 명시적인 잠금")]),_._v(" "),t("ul",[t("li",[_._v("데이터베이스에서 원자적 쓰기 연산을 제공하지 않는다면 애플리케이션에서 객체를 명시적으로 잠그는 방식으로 해결할 수 있다.")]),_._v(" "),t("li",[_._v("MySQL의 경우 SELECT 시 "),t("code",[_._v("FOR UPDATE")]),_._v(" 절을 활용하여 로우를 잠글 수 있다. 단, 명시적인 잠금 방식은 실수할 여지가 많다.")])]),_._v(" "),t("h4",{attrs:{id:"_3-갱신-손실-자동-감지"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-갱신-손실-자동-감지"}},[_._v("#")]),_._v(" 3) 갱신 손실 자동 감지")]),_._v(" "),t("ul",[t("li",[_._v("병렬 실행을 허용하도록 하고 갱신 손실을 자동 감지하여 발견 시 트랜잭션을 어보트 시키고 read-modify-write 주기를 재시도 하도록 강제하는 방법이 있다.")]),_._v(" "),t("li",[_._v("이 기능은 명시적인 잠금을 실수로 빼먹었을 때 자동으로 갱신 손실을 감지하여 트랜잭션을 어보트 시킬 수 있기 때문에 유용하다.")]),_._v(" "),t("li",[_._v("오라클, SQL 서버는 이 기능을 제공하지만 InnoDB 기반의 MySQL은 이 기능을 제공하지 않는다.")])])])}),[],!1,null,null,null);v.default=r.exports}}]);