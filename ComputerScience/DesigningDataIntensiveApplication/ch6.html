<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>데이터 중심 애플리케이션 설계 Ch 6. 파티셔닝 | BLOG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/img/favicon.svg">
    <meta name="description" content="">
    <meta name="google-site-verification" content="5Yx4T6uI30XHP7CaIBllI-z_pTFiIF9H73JCnPtoqu0">
    
    <link rel="preload" href="/blog/assets/css/0.styles.6deb2e86.css" as="style"><link rel="preload" href="/blog/assets/js/app.3dde727c.js" as="script"><link rel="preload" href="/blog/assets/js/18.65eaa4cd.js" as="script"><link rel="preload" href="/blog/assets/js/2.ab0ff3c0.js" as="script"><link rel="preload" href="/blog/assets/js/3.fb632d5d.js" as="script"><link rel="preload" href="/blog/assets/js/1.829eabcf.js" as="script"><link rel="preload" href="/blog/assets/js/28.4542f3d6.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.60a5b290.js"><link rel="prefetch" href="/blog/assets/js/11.ef976fef.js"><link rel="prefetch" href="/blog/assets/js/12.7340e6f1.js"><link rel="prefetch" href="/blog/assets/js/13.dab12b38.js"><link rel="prefetch" href="/blog/assets/js/14.20683788.js"><link rel="prefetch" href="/blog/assets/js/15.a2f05afc.js"><link rel="prefetch" href="/blog/assets/js/16.5f7b2c31.js"><link rel="prefetch" href="/blog/assets/js/17.842d2663.js"><link rel="prefetch" href="/blog/assets/js/19.8a1fa51e.js"><link rel="prefetch" href="/blog/assets/js/20.c90cbaa5.js"><link rel="prefetch" href="/blog/assets/js/21.86b937b4.js"><link rel="prefetch" href="/blog/assets/js/22.5dcd3ba9.js"><link rel="prefetch" href="/blog/assets/js/23.b3085c77.js"><link rel="prefetch" href="/blog/assets/js/24.41e02205.js"><link rel="prefetch" href="/blog/assets/js/25.642273b8.js"><link rel="prefetch" href="/blog/assets/js/26.15c29f40.js"><link rel="prefetch" href="/blog/assets/js/27.23a3fbdc.js"><link rel="prefetch" href="/blog/assets/js/29.59c89f8e.js"><link rel="prefetch" href="/blog/assets/js/30.2818bae9.js"><link rel="prefetch" href="/blog/assets/js/31.0a130bb6.js"><link rel="prefetch" href="/blog/assets/js/32.b34a17b7.js"><link rel="prefetch" href="/blog/assets/js/33.86cd2625.js"><link rel="prefetch" href="/blog/assets/js/34.dda955c9.js"><link rel="prefetch" href="/blog/assets/js/35.add71691.js"><link rel="prefetch" href="/blog/assets/js/36.faf76197.js"><link rel="prefetch" href="/blog/assets/js/37.c84ae923.js"><link rel="prefetch" href="/blog/assets/js/38.3ecab137.js"><link rel="prefetch" href="/blog/assets/js/39.e2521529.js"><link rel="prefetch" href="/blog/assets/js/4.2e364c8b.js"><link rel="prefetch" href="/blog/assets/js/40.82ab0fe7.js"><link rel="prefetch" href="/blog/assets/js/41.6e31b514.js"><link rel="prefetch" href="/blog/assets/js/42.8167fecf.js"><link rel="prefetch" href="/blog/assets/js/43.0886415c.js"><link rel="prefetch" href="/blog/assets/js/44.8a462e2c.js"><link rel="prefetch" href="/blog/assets/js/45.5b100788.js"><link rel="prefetch" href="/blog/assets/js/46.9c8a1263.js"><link rel="prefetch" href="/blog/assets/js/47.8bcb88fc.js"><link rel="prefetch" href="/blog/assets/js/48.12bc5de3.js"><link rel="prefetch" href="/blog/assets/js/49.23ab2876.js"><link rel="prefetch" href="/blog/assets/js/50.231b8599.js"><link rel="prefetch" href="/blog/assets/js/51.f20df7da.js"><link rel="prefetch" href="/blog/assets/js/52.b2e3abd5.js"><link rel="prefetch" href="/blog/assets/js/53.a6893760.js"><link rel="prefetch" href="/blog/assets/js/54.0ba1f515.js"><link rel="prefetch" href="/blog/assets/js/55.29f30120.js"><link rel="prefetch" href="/blog/assets/js/56.bf7abdf1.js"><link rel="prefetch" href="/blog/assets/js/57.c63a3297.js"><link rel="prefetch" href="/blog/assets/js/58.10fc19fe.js"><link rel="prefetch" href="/blog/assets/js/59.16240e09.js"><link rel="prefetch" href="/blog/assets/js/6.b3ff4a2a.js"><link rel="prefetch" href="/blog/assets/js/60.642a6336.js"><link rel="prefetch" href="/blog/assets/js/61.6bb93b84.js"><link rel="prefetch" href="/blog/assets/js/62.7b8f74f3.js"><link rel="prefetch" href="/blog/assets/js/63.e1e30188.js"><link rel="prefetch" href="/blog/assets/js/64.35394201.js"><link rel="prefetch" href="/blog/assets/js/65.2e0837c8.js"><link rel="prefetch" href="/blog/assets/js/66.7b297937.js"><link rel="prefetch" href="/blog/assets/js/67.e2c26b5e.js"><link rel="prefetch" href="/blog/assets/js/68.57fd2e08.js"><link rel="prefetch" href="/blog/assets/js/69.a11ff7d7.js"><link rel="prefetch" href="/blog/assets/js/7.dc4b9f31.js"><link rel="prefetch" href="/blog/assets/js/8.030a59d0.js"><link rel="prefetch" href="/blog/assets/js/9.914818a5.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.6deb2e86.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-fa8c0460><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="BLOG" class="logo"> <span class="site-name can-hide">BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Cassandra</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Cassandra/Cassandra_Consistency_Level.html" class="sidebar-link">카산드라 Consistency Level</a></li><li><a href="/blog/Cassandra/Cassandra_Eventual_And_Strong_Consistency.html" class="sidebar-link">카산드라 Eventual consistency vs Strong consistency</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>ComputerScience</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ComputerScience/BehavioralDesignPattern.html" class="sidebar-link">디자인 패턴(구조 패턴)</a></li><li><a href="/blog/ComputerScience/CharacterEncoding.html" class="sidebar-link">문자열 인코딩</a></li><li><a href="/blog/ComputerScience/CleanArchitecture.html" class="sidebar-link">클린 아키텍처</a></li><li><a href="/blog/ComputerScience/CreationalDesignPattern.html" class="sidebar-link">디자인 패턴(생성 패턴)</a></li><li><a href="/blog/ComputerScience/StructuralDesignPattern.html" class="sidebar-link">디자인 패턴(구조 패턴)</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/" class="sidebar-heading clickable router-link-active open"><span>데이터 중심 애플리케이션 설계</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch1.html" class="sidebar-link">Ch 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch2.html" class="sidebar-link">Ch 2. 데이터 모델과 질의 언어</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch3.html" class="sidebar-link">Ch 3. 저장소와 검색</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch4.html" class="sidebar-link">Ch 4. 부호화와 발전</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch5.html" class="sidebar-link">Ch 5. 복제</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html" aria-current="page" class="active sidebar-link">Ch 6. 파티셔닝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#파티셔닝과-복제" class="sidebar-link">파티셔닝과 복제</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#키-값-데이터-파티셔닝" class="sidebar-link">키-값 데이터 파티셔닝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#_1-키-범위-기준-파티셔닝" class="sidebar-link">1. 키 범위 기준 파티셔닝</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#_2-키의-해시값-기준-파티셔닝" class="sidebar-link">2. 키의 해시값 기준 파티셔닝</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#파티셔닝과-보조-색인-secondary-index" class="sidebar-link">파티셔닝과 보조 색인(secondary index)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#_1-문서-기준-보조-색인-파티셔닝" class="sidebar-link">1. 문서 기준 보조 색인 파티셔닝</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#_2-용어-기준-보조-색인-파티셔닝" class="sidebar-link">2. 용어 기준 보조 색인 파티셔닝</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#파티셔닝과-재균형화" class="sidebar-link">파티셔닝과 재균형화</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#리밸런싱-전략" class="sidebar-link">리밸런싱 전략</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#운영-자동-리밸런싱과-수동-리밸런싱" class="sidebar-link">운영: 자동 리밸런싱과 수동 리밸런싱</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#요청-라우팅" class="sidebar-link">요청 라우팅</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#정리" class="sidebar-link">정리</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#두-가지-주요-파티셔닝-기법" class="sidebar-link">두 가지 주요 파티셔닝 기법</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#두-가지-보조-색인-파티셔닝-기법" class="sidebar-link">두 가지 보조 색인 파티셔닝 기법</a></li></ul></li></ul></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html" class="sidebar-link">Ch 7. 트랜잭션</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html" class="sidebar-link">Ch 8. 분산 시스템의 골칫거리</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Groovy</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Groovy/spock-summary.html" class="sidebar-link">Spock 사용 시 주의해야 할 것들</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Java/EffectiveJava.html" class="sidebar-link">Effective Java 3/E 정리</a></li><li><a href="/blog/Java/UseThreadLocalWhenAsyncCall.html" class="sidebar-link">비동기 호출 시 ThreadLocal 값 유지하기</a></li><li><a href="/blog/Java/awsEc2InstallJDK11.html" class="sidebar-link">AWS EC2에 JDK 11 설치하기</a></li><li><a href="/blog/Java/javaCodingSkill.html" class="sidebar-link">자바 코딩의 기술 정리</a></li><li><a href="/blog/Java/javaOverloadingParameter.html" class="sidebar-link">JAVA 매개변수(Parameter)수가 같은 오버로딩 메서드가 위험한 이유</a></li><li><a href="/blog/Java/resilience4j.html" class="sidebar-link">resilience4j Circuit Breaker</a></li><li><a href="/blog/Java/threadPoolExecutor.html" class="sidebar-link">Java의 ThreadPoolExecutor, Spring의 ThreadPoolTaskExecutor</a></li><li><a href="/blog/Java/whyCantCreateGenericsArray.html" class="sidebar-link">JAVA 제네릭 배열을 생성하지 못하는 이유</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Kotlin</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Kotlin/Coroutines.html" class="sidebar-link">코틀린 코루틴(Coroutine)</a></li><li><a href="/blog/Kotlin/ScopeFunctions.html" class="sidebar-link">코틀린 Scope functions(let, with, run, apply, also)</a></li><li><a href="/blog/Kotlin/kotlinInAction.html" class="sidebar-link">코틀린 인 액션 정리</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Network</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Network/HttpNetworkBasic.html" class="sidebar-link">그림으로 배우는 Http Network Basic 정리</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Spring</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Spring/DI_IOC.html" class="sidebar-link">Java, Spring 의존성 주입(DI), 제어의 역전(IoC)</a></li><li><a href="/blog/Spring/MockMvc_Encoding.html" class="sidebar-link">MockMvc 한글 깨짐 현상</a></li><li><a href="/blog/Spring/PropertySourceConfigurer.html" class="sidebar-link">애너테이션을 사용하지 않고 PropertySource 등록하기</a></li><li><a href="/blog/Spring/Scheduler.html" class="sidebar-link">스프링 TaskScheduler(@EnableScheduling, @Scheduled)</a></li><li><a href="/blog/Spring/SpringBoot_Custom_Config_Properties.html" class="sidebar-link">SpringBoot Type-Safe하게 Property 설정하기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Vue/N1VuePressCh1.html" class="sidebar-link">VuePress로 블로그 제작 1 시작하기</a></li><li><a href="/blog/Vue/N2VuePressCh2.html" class="sidebar-link">VuePress로 블로그 제작 2 배포하기</a></li><li><a href="/blog/Vue/vuexModuleAutoRegister.html" class="sidebar-link">Vuex 모듈 등록 자동화하기</a></li></ul></section></li></ul> </aside> <aside class="rightbar" data-v-40a14b8c><div class="pr-2" data-v-689e6835 data-v-40a14b8c><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#파티셔닝과-복제" class="rightbar-link" data-v-689e6835>
      파티셔닝과 복제
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#키-값-데이터-파티셔닝" class="rightbar-link" data-v-689e6835>
      키-값 데이터 파티셔닝
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#_1-키-범위-기준-파티셔닝" class="rightbar-link" data-v-689e6835>
      1. 키 범위 기준 파티셔닝
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#_2-키의-해시값-기준-파티셔닝" class="rightbar-link" data-v-689e6835>
      2. 키의 해시값 기준 파티셔닝
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#파티셔닝과-보조-색인-secondary-index" class="rightbar-link" data-v-689e6835>
      파티셔닝과 보조 색인(secondary index)
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#_1-문서-기준-보조-색인-파티셔닝" class="rightbar-link" data-v-689e6835>
      1. 문서 기준 보조 색인 파티셔닝
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#_2-용어-기준-보조-색인-파티셔닝" class="rightbar-link" data-v-689e6835>
      2. 용어 기준 보조 색인 파티셔닝
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#파티셔닝과-재균형화" class="rightbar-link" data-v-689e6835>
      파티셔닝과 재균형화
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#리밸런싱-전략" class="rightbar-link" data-v-689e6835>
      리밸런싱 전략
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#운영-자동-리밸런싱과-수동-리밸런싱" class="rightbar-link" data-v-689e6835>
      운영: 자동 리밸런싱과 수동 리밸런싱
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#요청-라우팅" class="rightbar-link" data-v-689e6835>
      요청 라우팅
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#정리" class="rightbar-link" data-v-689e6835>
      정리
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#두-가지-주요-파티셔닝-기법" class="rightbar-link" data-v-689e6835>
      두 가지 주요 파티셔닝 기법
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#두-가지-보조-색인-파티셔닝-기법" class="rightbar-link" data-v-689e6835>
      두 가지 보조 색인 파티셔닝 기법
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div></div></aside> <main class="page"><div class="block content-title" data-v-73713578 data-v-fa8c0460><div style="width: 100%" data-v-73713578><div class="w-11/12 mx-auto title" data-v-73713578><h1 class="title" data-v-73713578>데이터 중심 애플리케이션 설계 Ch 6. 파티셔닝</h1></div> <div class="text--primary text-right w-95 mr-5 my-2" data-v-73713578>
      작성일: 2021-11-09 01:41
    </div> <div class="w-100 text-center" data-v-73713578><!----></div> <hr class="content-divider" data-v-73713578></div></div> <div class="theme-default-content content__default"><h2 id="파티셔닝과-복제"><a href="#파티셔닝과-복제" class="header-anchor">#</a> 파티셔닝과 복제</h2> <p>데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로 부족하고 데이터를 <code>파티션</code>으로 쪼갤 필요가 있다. 이 작업을 <code>샤딩</code>이라고 한다.</p> <p>여기서 말하는 <code>파티션</code>은 몽고DB, ES의 <code>샤드(shard)</code>에 해당한다. HBase에서는 <code>리전(region)</code>, 빅테이블에서는 <code>태블릿(tablet)</code>, 카산드라와 리악에서는 <code>브이노드(vnode)</code>이다.</p> <p>각 파티션은 그 자체로 작은 데이터베이스가 되며 각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있으므로 노드를 추가함으로써 질의 처리량을 늘릴 수 있다.</p> <p><strong>데이터 파티셔닝의 주된 이유는 <code>확장성</code>이다.</strong></p> <p>보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.</p> <ul><li>한 노드에 여러 파티션을 저장하기도 한다.</li></ul> <h2 id="키-값-데이터-파티셔닝"><a href="#키-값-데이터-파티셔닝" class="header-anchor">#</a> 키-값 데이터 파티셔닝</h2> <p><strong>파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.</strong></p> <ul><li>파티셔닝이 고르게 이루어지지 않아 한 파티션이 많은 데이터를 가지거나 많은 질의를 받는다면 <code>쏠렸다(skewed)</code>고 말하며 불균형하게 부하가 높은 파티션을 <code>핫스팟</code>이라고 한다.</li> <li>어떤 레코드를 어느 노드에 저장할지 어떻게 결정해야 할까?</li></ul> <h3 id="_1-키-범위-기준-파티셔닝"><a href="#_1-키-범위-기준-파티셔닝" class="header-anchor">#</a> 1. 키 범위 기준 파티셔닝</h3> <ul><li>백과사전처럼 각 파티션에 연속된 범위의 키를 할당하는 방식이다.</li> <li>각 범위들의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다.</li> <li><strong>그러나 키 범위 기준 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발하는 단점이 있다.</strong> <ul><li>특정 키 범위에만 부하가 몰려 특정 파티션에만 과부화가 걸릴 수 있다.</li></ul></li> <li>HBase, 리싱크DB, 2.4버전 이전의 몽고DB에서 사용된다.</li></ul> <h3 id="_2-키의-해시값-기준-파티셔닝"><a href="#_2-키의-해시값-기준-파티셔닝" class="header-anchor">#</a> 2. 키의 해시값 기준 파티셔닝</h3> <ul><li><code>쏠림</code>과 <code>핫스팟</code>의 위험 때문에 많은 분산 데이터스토어는 키의 파티션을 정하는 데 <code>해시 함수</code>를 사용한다.
<ul><li>좋은 해시 함수는 쏠린 데이터를 균일하게 분산시킨다.</li> <li><strong>파티셔닝용 해시 함수는 암호학적으로 강력할 필요는 없다.</strong> 카산드라는 MD5를 사용한다.</li></ul></li> <li>키 범위 파티셔닝에 비해 <strong>키의 해시 값 기준 파티셔닝은 범위 질의를 효율적으로 실행할 수 없다.</strong> <ul><li>카산드라의 경우 두 전략을 모두 활용한다.</li> <li><code>primary key</code>를 통해 파티션을 결정하고 <code>clustering key</code>를 통해 SS테이블에서 데이터가 정렬되도록 하여 <code>primary key</code>를 지정한다면 범위 질의를 효율적으로 실행할 수 있다.</li></ul></li></ul> <h4 id="쏠린-작업부하와-핫스팟-완화"><a href="#쏠린-작업부하와-핫스팟-완화" class="header-anchor">#</a> 쏠린 작업부하와 핫스팟 완화</h4> <ul><li>해시값 기준 파티셔닝은 핫스팟을 줄여주지만 동일한 키를 읽고 쓰는 극단적 상황에서는 핫스팟이 발생할 수 있다.</li> <li>현대 데이터 시스템은 대부분 크게 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완하해야 한다.
<ul><li>키의 끝에 임의로 숫자를 붙일 수 있다.</li></ul></li></ul> <h2 id="파티셔닝과-보조-색인-secondary-index"><a href="#파티셔닝과-보조-색인-secondary-index" class="header-anchor">#</a> 파티셔닝과 보조 색인(secondary index)</h2> <p><code>보조 색인</code>은 보통 레코드를 유일하게 식별하는 용도가 아닌 특정한 값이 발생한 항목을 검색하는 수단이다.</p> <p>보조 색인은 RDB에서 핵심 요소이며 솔라나 엘라스틱서치와 같은 검색 서버에서 <code>존재의 이유</code>다.</p> <ul><li>많은 키-값 저장소에서는 구현 복잡도로 인해 지원하지 않는다.</li></ul> <p><strong>보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점</strong>이 있고, 보조 색인이 있는 데이터베이스를 파티셔닝하는데 널리 쓰이는 두 가지 방법이 있다.</p> <h3 id="_1-문서-기준-보조-색인-파티셔닝"><a href="#_1-문서-기준-보조-색인-파티셔닝" class="header-anchor">#</a> 1. 문서 기준 보조 색인 파티셔닝</h3> <img src="/blog/assets/img/secondary-index-by-document.86fb9c63.png"> <ul><li>각 항목에는 고유한 <code>document ID</code>가 있고 데이터베이스를 document ID 기준으로 파티셔닝한다.</li> <li>이 방식은 파티션별 자신의 보조 색인을 유지하는 방식으로 각 파티션이 완전히 독립적으로 동작한다.
<ul><li>이러한 특징으로 인해 문서 파티셔닝 색인은 <code>지역 색인(local index)</code>라고도 한다.</li></ul></li> <li>문서 파티셔닝 색인은 <strong>보조 색인으로 검색하기 위해 모든 파티션에 질의를 보내서 얻을 결과를 모두 모아야 한다.</strong> <ul><li>이런 방식을 <code>스캐터/개터(scatter/gather)</code>라고 한다.</li> <li>보조 색인으로 검색 시 큰 비용이 들 수 있지만 <strong>보조 색인을 문서 기준으로 파티셔닝하는 경우가 많다.</strong> <ul><li>몽고DB, 리악, 카산드라, ES 등은 모두 문서 기준으로 파티셔닝된 보조 색인을 사용한다.</li></ul></li></ul></li></ul> <h3 id="_2-용어-기준-보조-색인-파티셔닝"><a href="#_2-용어-기준-보조-색인-파티셔닝" class="header-anchor">#</a> 2. 용어 기준 보조 색인 파티셔닝</h3> <img src="/blog/assets/img/secondary-index-by-term.0e8b0f64.png"> <ul><li>각 파티션이 자신만의 보조 색인(지역 색인)을 갖는 대신 모든 파티션을 담당하는 <code>전역 색인</code>을 가진다.
<ul><li>전역 색인 또한 파티셔닝이 필요하지만 기본키 색인과는 다른식으로 할 수 있다.</li></ul></li> <li>찾고자 하는 용어에 따라 색인의 파티션이 결정되므로 <code>용어 기준 보조 색인 파티셔닝</code>이라고 하며 <code>color:red</code>가 예이다.
<ul><li>문서 기준 보조 색인 파티셔닝에서는 <code>color:red</code> 색인이 각 파티션별 따로 존재했지만 여기선 파티션 0에만 존재한다.</li></ul></li> <li><strong>색인이 한 파티션에 존재해 문서 기준 보조 색인 파티셔닝보다 읽기가 효율적이지만 쓰기가 느리고 복잡하다는 단점이 있다.</strong> <ul><li>단일 문서를 쓸 때 색인으로 인해 여러 파티션에 영향을 줄 수 있다.</li> <li>이상적인 색인이라면 항상 최신 상태에 있어야 하지만 용어 파티셔닝 색인을 사용하면 분산 트랜잭션이 필요해지고 이는 모든 데이터베이스에서 지원되지 않고 현실적으로 비동기로 수행된다.</li> <li>대표적인 사용처는 리악, 오라클 데이터 웨어하우스가 있다.</li></ul></li></ul> <h2 id="파티셔닝과-재균형화"><a href="#파티셔닝과-재균형화" class="header-anchor">#</a> 파티셔닝과 재균형화</h2> <ul><li>시간이 지나면 데이터베이스에 변화가 생기고 새로운 노드를 추가가 필요해진다.
<ul><li>높은 부하를 처리하기 위해</li> <li>데이터셋 크기가 증가</li> <li>장애로 인한 노드 변경</li></ul></li> <li>클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 <code>재균형화(rebalancing)</code>라고 한다.</li> <li>리밸런싱이 일어날 때 보통 기대하는 최소 요구사항은 다음과 같다.
<ul><li>리밸런싱 후 <strong>부하가 균등하게 분배되어야 한다.</strong></li> <li>리밸런싱 <strong>도중에도 읽기 쓰기 요청이 가능해야 한다.</strong></li> <li><strong>노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안된다.</strong></li></ul></li></ul> <h3 id="리밸런싱-전략"><a href="#리밸런싱-전략" class="header-anchor">#</a> 리밸런싱 전략</h3> <h4 id="_1-해시값에-mod-n-연산-수행-쓰며-안됨"><a href="#_1-해시값에-mod-n-연산-수행-쓰며-안됨" class="header-anchor">#</a> 1)해시값에 mod N 연산 수행(쓰며 안됨)</h4> <ul><li><strong>mod N 방식은 N(노드 개수)이 바뀌면 대부분의 키가 노드 사이에 옮겨져야 해 리밸런싱 비용이 지나치게 커진다.</strong> <ul><li><code>(123456 mod 10 = 6)</code>, <code>(123456 mod 11 = 3)</code>, <code>(123456 mod 12 = 0)</code></li> <li>N이 증가할 때 마다 대상 노드가 계속 바뀌기 때문에 비효율적이다.</li></ul></li></ul> <h4 id="_2-파티션-개수-고정"><a href="#_2-파티션-개수-고정" class="header-anchor">#</a> 2) 파티션 개수 고정</h4> <ul><li>파티션을 노드 대수보다 많이 만들고 <strong>각 노드에 여러 파티션을 할당하여 데이터를 최소한으로 이동시킬 수 있다.</strong></li> <li>클러스터에 노드가 추가되면 <strong>새 노드는 기존 노드에서 파티션을 몇개 뺏어와 파티션을 균일하게 맞춘다.</strong> <ul><li>파티션은 노드 사이에서 통쨰로 이동하기만 한다. 파티션 개수는 바뀌지 않고 파티션에 할당된 키도 변경되지 않는다.</li> <li><strong>오직 노드에 어떤 파티션이 할당되는가만 변경된다.</strong></li></ul></li> <li>이 방식을 사용할 땐 보통 처음 데이터베이스가 구축될 때 파티션 개수를 고정하고 그 이후에 변경하지 않는다.
<ul><li>파티션 개수를 고정하면 운영이 단순해지므로 분할을 지원하지 않는 경우도 많다.</li></ul></li> <li>파티션이 너무 크면 리밸런싱 및 복구의 비용이크고, 너무 작으면 오버헤드가 커진다.</li> <li><strong>파티션 크기가 <code>딱 적당할 때</code> 성능이 가장 좋지만 데이터셋 크기는 변하고 파티션 개수는 고정되어 있어 크기를 정하기 어려울 수 있다.</strong></li></ul> <h4 id="_3-동적-파티셔닝"><a href="#_3-동적-파티셔닝" class="header-anchor">#</a> 3) 동적 파티셔닝</h4> <ul><li><strong>키 범위 파티셔닝을 사용하는 경우 파티션 경계를 잘못 지정하면 파티션 쏠림이 발생할 수 있어 파티션 경계와 개수가 고정되어 있는 방식은 매우 불편하다.</strong></li> <li>이런 경우 파티션 크기가 설정된 값을 넘어설 때 파티션을 두 개로 쪼개어 동적 파티셔닝을 할 수 있다.
<ul><li>임계값 아래로 떨어지면 다시 합친다.</li> <li>키 범위 파티셔닝을 사용하는 HBase나 리싱크DB등이 동적 파티셔닝을 사용한다.</li></ul></li> <li><strong>동적 파티셔닝은 파티션 개수가 전체 데이터 용량에 맞춰 조정되는 이점이 있다.</strong> <ul><li>단, 데이터베이스 시작 시점에 파티션 경계를 나눌 사전 정보가 없어 파티션이 하나가 된다.</li> <li>이를 해결하기 위해 빈 데이터베이스에 초기 파티션 집합을 설정할 수 있도록 지원한다.</li></ul></li> <li>동적 파티셔닝은 키 범위 파티셔닝뿐만 아니라 해시 파티셔닝에서도 똑같이 활용될 수 있다.</li></ul> <h4 id="_4-노드-비례-파티셔닝"><a href="#_4-노드-비례-파티셔닝" class="header-anchor">#</a> 4) 노드 비례 파티셔닝</h4> <ul><li>이 방식은 <code>노드 당</code> 할당되는 <strong>파티션 개수를 고정하여 노드의 증감유무에 따라 파티션의 크기가 달라지도록 한다.</strong> <ul><li><strong>카산드라에서 사용하는 방식</strong>으로 노드가 유지될 때는 개별 파티션의 크기가 데이터셋 크기에 따라 증가하지만 노드 대수를 늘리면 다시 작아진다.</li> <li>이전의 두 방식은 노드에 독립적으로 데이터셋 크기에 따라 파티션의 크기와 파티션의 수가 증가하지만 <strong>이 방식은 노드 수에 따라 파티션의 크기가 변화한다.</strong></li></ul></li> <li>새 노드가 추가되면 고정된 개수의 <strong>파티션을 무작위로 선택해 분할하고 분할된 각 파티션의 절반은 그대로 두고 다른 절반은 새 노드에 할당한다.</strong></li></ul> <h3 id="운영-자동-리밸런싱과-수동-리밸런싱"><a href="#운영-자동-리밸런싱과-수동-리밸런싱" class="header-anchor">#</a> 운영: 자동 리밸런싱과 수동 리밸런싱</h3> <ul><li>완전 자동 방식은 유지보수가 덜하겠지만 예측이 어렵다.
<ul><li>트래픽 증가로 인해 일시적인 장애로 응답이 느려졌는데 노드가 죽었다고 판단해 리밸런싱이 발생하여 더 많은 부하를 줘 상황을 더 악화시킬 수 있다.</li></ul></li> <li>이런 이유로 리밸런싱 과정에 사람이 개입하는게 좋을 수 있다. 완정 자동보단 느리겠지만 운영상 예상치 못한 일을 방지하는데 도움이될 수 있다.</li></ul> <h2 id="요청-라우팅"><a href="#요청-라우팅" class="header-anchor">#</a> 요청 라우팅</h2> <p>클라이언트에서 요청을 보내려고할 때 어느 노드에 접속해야하는지 어떻게 알 수 있을까? 파티션은 리밸런싱되어 노드에 할당되는 파티션이 바뀌는데 어떻게 알 수 있을까?</p> <p>이를 위해 크게 3 가지 접근법이 있다.</p> <ol><li>클라이언트가 아무 노드에나 접속하게 하고 해당 노드에서 대상 노드로 요청을 전달하고 응답을 받아 클라이언트에게 응답해준다.</li> <li>클라이언트의 모든 요청을 라우팅 계층으로 보내고, 각 라우팅 계층에서 대상 노드를 찾아 라우팅한다.</li> <li>클라이언트가 노드의 정보를 알고있도록 하여 클라이언트가 알아서 판단해서 대상 노드로 요청을 보내도록 한다.</li></ol> <p>위 방식 모드 핵심 문제는 <strong>라우팅 결정을 내리는 구성요소가 노드에 할당된 파티션의 변경을 어떻게 아는지이다.</strong></p> <ul><li>많은 분산 데이터 시스템은 클러스터 메타데이터를 추적하기 위해 주키퍼와 같은 코디네이션 서비스를 사용한다.
<ul><li>HBase, 카프카등이 주키퍼를 사용한다.</li></ul></li> <li><code>카산드라</code>와 리악은 <code>가십 프로토콜(gossip protocol)</code>을 사용하여 클러스터 상태 변화를 노드 사이에 퍼트린다.
<ul><li>노드간 상태 변화를 주고받기 때문에 1번 방식을 사용해야 한다.</li> <li>데이터베이스에 복잡성은 증가하지만 주키퍼와 같은 외부 코디네이션 서비스에 의존하지 않는다.</li></ul></li></ul> <h2 id="정리"><a href="#정리" class="header-anchor">#</a> 정리</h2> <p>파티셔닝의 목적은 데이터와 질의 부하를 여러 노드에 균일하게 분배하는 것이다.</p> <h3 id="두-가지-주요-파티셔닝-기법"><a href="#두-가지-주요-파티셔닝-기법" class="header-anchor">#</a> 두 가지 주요 파티셔닝 기법</h3> <h4 id="_1-키-범위-파티셔닝"><a href="#_1-키-범위-파티셔닝" class="header-anchor">#</a> 1) 키 범위 파티셔닝</h4> <ul><li>키가 정렬돼 있어 범위 질의가 효율적이지만 핫스팟이 생길 위험이 있다.</li> <li>한 파티션이 너무 커지면 키 범위를 두 개로 쪼개는 동적 파티셔닝을 통해 리밸런싱 한다.</li></ul> <h4 id="_2-해시-파티셔닝"><a href="#_2-해시-파티셔닝" class="header-anchor">#</a> 2) 해시 파티셔닝</h4> <ul><li>해시 함수를 통해 키를 균일하게 분산시킬 수 있지만 범위 질의가 비효율적이다.</li> <li>노드 수 보다 많은 고정된 개수의 파티션을 미리 정해놓고 파티션을 통째로 노드 사이에서 이동하는 리밸런싱 방식을 주로 사용한다.</li> <li>카산드라 같은 경우 두 가지 방식을 혼합해서 사용한다.</li></ul> <h3 id="두-가지-보조-색인-파티셔닝-기법"><a href="#두-가지-보조-색인-파티셔닝-기법" class="header-anchor">#</a> 두 가지 보조 색인 파티셔닝 기법</h3> <h4 id="_1-문서-파티셔닝-색인-지역-색인"><a href="#_1-문서-파티셔닝-색인-지역-색인" class="header-anchor">#</a> 1) 문서 파티셔닝 색인(지역 색인)</h4> <ul><li>보조 색인을 기본키와 값이 저장된 파티션에 함께 저장하기 때문에 쓰기 시 단일 파티션만 수정하면 되지만 읽기 시 모든 파티션을 조회해야 하므로 비효율적이다.</li></ul> <h4 id="_2-용어-파티셔닝-색인-전략-색인"><a href="#_2-용어-파티셔닝-색인-전략-색인" class="header-anchor">#</a> 2) 용어 파티셔닝 색인(전략 색인)</h4> <ul><li>보조 색인을 별도로 파티셔닝하여 단일 파티션에 저장하기 때문에 읽기 시 단일 파티션만 조회하면 되지만 쓰기 시 여러 파티션에 영향을 줄 수 있다.</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch5.html" class="prev">
        Ch 5. 복제
      </a></span> <span class="next"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html">
        Ch 7. 트랜잭션
      </a>
      →
    </span></p></div> <div data-v-0eb52d94 data-v-fa8c0460></div></main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.3dde727c.js" defer></script><script src="/blog/assets/js/18.65eaa4cd.js" defer></script><script src="/blog/assets/js/2.ab0ff3c0.js" defer></script><script src="/blog/assets/js/3.fb632d5d.js" defer></script><script src="/blog/assets/js/1.829eabcf.js" defer></script><script src="/blog/assets/js/28.4542f3d6.js" defer></script>
  </body>
</html>
