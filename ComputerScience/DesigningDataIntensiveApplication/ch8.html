<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>데이터 중심 애플리케이션 설계 Ch 8. 분산 시스템의 골칫거리 | BLOG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/img/favicon.svg">
    <meta name="description" content="">
    <meta name="google-site-verification" content="5Yx4T6uI30XHP7CaIBllI-z_pTFiIF9H73JCnPtoqu0">
    
    <link rel="preload" href="/blog/assets/css/0.styles.4b797a7a.css" as="style"><link rel="preload" href="/blog/assets/js/app.a8f3d420.js" as="script"><link rel="preload" href="/blog/assets/js/18.20581197.js" as="script"><link rel="preload" href="/blog/assets/js/2.6e22e42d.js" as="script"><link rel="preload" href="/blog/assets/js/3.48647491.js" as="script"><link rel="preload" href="/blog/assets/js/1.784377b9.js" as="script"><link rel="preload" href="/blog/assets/js/33.4e277b33.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.5ef4b2ee.js"><link rel="prefetch" href="/blog/assets/js/11.f4cb4270.js"><link rel="prefetch" href="/blog/assets/js/12.9653b88d.js"><link rel="prefetch" href="/blog/assets/js/13.a4ab9b72.js"><link rel="prefetch" href="/blog/assets/js/14.639e7b7f.js"><link rel="prefetch" href="/blog/assets/js/15.28da3ee9.js"><link rel="prefetch" href="/blog/assets/js/16.4c7b80e9.js"><link rel="prefetch" href="/blog/assets/js/17.89f1ba0d.js"><link rel="prefetch" href="/blog/assets/js/19.d2ef1650.js"><link rel="prefetch" href="/blog/assets/js/20.d8de11d4.js"><link rel="prefetch" href="/blog/assets/js/21.134593a5.js"><link rel="prefetch" href="/blog/assets/js/22.0fd01aa0.js"><link rel="prefetch" href="/blog/assets/js/23.55f10ed1.js"><link rel="prefetch" href="/blog/assets/js/24.395d537e.js"><link rel="prefetch" href="/blog/assets/js/25.6ce0cf81.js"><link rel="prefetch" href="/blog/assets/js/26.bba7c120.js"><link rel="prefetch" href="/blog/assets/js/27.fdd6c89e.js"><link rel="prefetch" href="/blog/assets/js/28.ab65778d.js"><link rel="prefetch" href="/blog/assets/js/29.4625c0f5.js"><link rel="prefetch" href="/blog/assets/js/30.72507a3e.js"><link rel="prefetch" href="/blog/assets/js/31.a4ce8064.js"><link rel="prefetch" href="/blog/assets/js/32.6adfaa67.js"><link rel="prefetch" href="/blog/assets/js/34.7392d4eb.js"><link rel="prefetch" href="/blog/assets/js/35.73c42683.js"><link rel="prefetch" href="/blog/assets/js/36.c8f0bddf.js"><link rel="prefetch" href="/blog/assets/js/37.541185eb.js"><link rel="prefetch" href="/blog/assets/js/38.eb5dc864.js"><link rel="prefetch" href="/blog/assets/js/39.700e54dd.js"><link rel="prefetch" href="/blog/assets/js/4.292cb649.js"><link rel="prefetch" href="/blog/assets/js/40.f066f8b0.js"><link rel="prefetch" href="/blog/assets/js/41.6ef63b28.js"><link rel="prefetch" href="/blog/assets/js/42.694381eb.js"><link rel="prefetch" href="/blog/assets/js/43.2cd683e6.js"><link rel="prefetch" href="/blog/assets/js/44.e52b8d6c.js"><link rel="prefetch" href="/blog/assets/js/45.0de814b3.js"><link rel="prefetch" href="/blog/assets/js/46.dd4d7a30.js"><link rel="prefetch" href="/blog/assets/js/47.df4acd73.js"><link rel="prefetch" href="/blog/assets/js/48.f229666d.js"><link rel="prefetch" href="/blog/assets/js/49.482a2137.js"><link rel="prefetch" href="/blog/assets/js/50.0467d27f.js"><link rel="prefetch" href="/blog/assets/js/51.b65f52ad.js"><link rel="prefetch" href="/blog/assets/js/52.e88291c1.js"><link rel="prefetch" href="/blog/assets/js/53.c06f3ee2.js"><link rel="prefetch" href="/blog/assets/js/54.b502704d.js"><link rel="prefetch" href="/blog/assets/js/55.9461e406.js"><link rel="prefetch" href="/blog/assets/js/56.c053ba34.js"><link rel="prefetch" href="/blog/assets/js/57.c67435f5.js"><link rel="prefetch" href="/blog/assets/js/58.3a4070ac.js"><link rel="prefetch" href="/blog/assets/js/59.f9782675.js"><link rel="prefetch" href="/blog/assets/js/6.0b343535.js"><link rel="prefetch" href="/blog/assets/js/60.4ebd2f79.js"><link rel="prefetch" href="/blog/assets/js/61.1c4d0dd4.js"><link rel="prefetch" href="/blog/assets/js/62.ad72fb75.js"><link rel="prefetch" href="/blog/assets/js/63.d9720adb.js"><link rel="prefetch" href="/blog/assets/js/64.8f525e93.js"><link rel="prefetch" href="/blog/assets/js/65.aae731c5.js"><link rel="prefetch" href="/blog/assets/js/66.a266b0a3.js"><link rel="prefetch" href="/blog/assets/js/67.d1584ffd.js"><link rel="prefetch" href="/blog/assets/js/68.6bbe2970.js"><link rel="prefetch" href="/blog/assets/js/69.05266776.js"><link rel="prefetch" href="/blog/assets/js/7.c33589c7.js"><link rel="prefetch" href="/blog/assets/js/8.628231ed.js"><link rel="prefetch" href="/blog/assets/js/9.f1dacad7.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.4b797a7a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-fa8c0460><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="BLOG" class="logo"> <span class="site-name can-hide">BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Cassandra</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Cassandra/Cassandra_Consistency_Level.html" class="sidebar-link">카산드라 Consistency Level</a></li><li><a href="/blog/Cassandra/Cassandra_Eventual_And_Strong_Consistency.html" class="sidebar-link">카산드라 Eventual consistency vs Strong consistency</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>ComputerScience</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ComputerScience/BehavioralDesignPattern.html" class="sidebar-link">디자인 패턴(행동 패턴)</a></li><li><a href="/blog/ComputerScience/CharacterEncoding.html" class="sidebar-link">문자열 인코딩</a></li><li><a href="/blog/ComputerScience/CreationalDesignPattern.html" class="sidebar-link">디자인 패턴(생성 패턴)</a></li><li><a href="/blog/ComputerScience/StructuralDesignPattern.html" class="sidebar-link">디자인 패턴(구조 패턴)</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/" class="sidebar-heading clickable router-link-active open"><span>데이터 중심 애플리케이션 설계</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch1.html" class="sidebar-link">Ch 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch2.html" class="sidebar-link">Ch 2. 데이터 모델과 질의 언어</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch3.html" class="sidebar-link">Ch 3. 저장소와 검색</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch4.html" class="sidebar-link">Ch 4. 부호화와 발전</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch5.html" class="sidebar-link">Ch 5. 복제</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html" class="sidebar-link">Ch 6. 파티셔닝</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html" class="sidebar-link">Ch 7. 트랜잭션</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html" aria-current="page" class="active sidebar-link">Ch 8. 분산 시스템의 골칫거리</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#결함과-부분-장애" class="sidebar-link">결함과 부분 장애</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#신뢰성-없는-구성-요소를-사용해-신뢰성-있는-시스템-구축한-예" class="sidebar-link">신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템 구축한 예</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#신뢰성-없는-네트워크" class="sidebar-link">신뢰성 없는 네트워크</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#현실의-네트워크-결함" class="sidebar-link">현실의 네트워크 결함</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#타임아웃과-기약-없는-지연" class="sidebar-link">타임아웃과 기약 없는 지연</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#동기-네트워크-vs-비동기-네트워크" class="sidebar-link">동기 네트워크 vs 비동기 네트워크</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#신뢰성-없는-시계" class="sidebar-link">신뢰성 없는 시계</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#일-기준-시계-대-단조-시계" class="sidebar-link">일 기준 시계 대 단조 시계</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#시계-동기화와-정확도" class="sidebar-link">시계 동기화와 정확도</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#지식-진실-그리고-거짓말" class="sidebar-link">지식, 진실, 그리고 거짓말</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#진실은-다수결로-결정된다" class="sidebar-link">진실은 다수결로 결정된다</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#리더와-잠금" class="sidebar-link">리더와 잠금</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#펜싱-토큰" class="sidebar-link">펜싱 토큰</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#비잔틴-결함" class="sidebar-link">비잔틴 결함</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#정리" class="sidebar-link">정리</a></li></ul></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch9.html" class="sidebar-link">Ch 9. 일관성과 합의</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Groovy</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Groovy/spock-summary.html" class="sidebar-link">Spock 사용 시 주의해야 할 것들</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Java/CircuitBreaker.html" class="sidebar-link">Circuit Breaker 패턴, resilience4j Circuit Breaker</a></li><li><a href="/blog/Java/EffectiveJava.html" class="sidebar-link">Effective Java 3/E 정리</a></li><li><a href="/blog/Java/UseThreadLocalWhenAsyncCall.html" class="sidebar-link">비동기 호출 시 ThreadLocal 값 유지하기</a></li><li><a href="/blog/Java/awsEc2InstallJDK11.html" class="sidebar-link">AWS EC2에 JDK 11 설치하기</a></li><li><a href="/blog/Java/javaOverloadingParameter.html" class="sidebar-link">JAVA 매개변수(Parameter)수가 같은 오버로딩 메서드가 위험한 이유</a></li><li><a href="/blog/Java/threadPoolExecutor.html" class="sidebar-link">Java의 ThreadPoolExecutor, Spring의 ThreadPoolTaskExecutor</a></li><li><a href="/blog/Java/whyCantCreateGenericsArray.html" class="sidebar-link">JAVA 제네릭 배열을 생성하지 못하는 이유</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Kotlin</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Kotlin/Coroutines.html" class="sidebar-link">코틀린 코루틴(Coroutine)</a></li><li><a href="/blog/Kotlin/ScopeFunctions.html" class="sidebar-link">코틀린 Scope functions(let, with, run, apply, also)</a></li><li><a href="/blog/Kotlin/kotlinInAction.html" class="sidebar-link">코틀린 인 액션 정리</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Redis</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Redis/LocalCacheSyncWithRedisPubSub.html" class="sidebar-link">Redis(Pub/Sub)로 로컬 캐시 동기화하기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Spring</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Spring/DI_IOC.html" class="sidebar-link">Java, Spring 의존성 주입(DI), 제어의 역전(IoC)</a></li><li><a href="/blog/Spring/MockMvc_Encoding.html" class="sidebar-link">MockMvc 한글 깨짐 현상</a></li><li><a href="/blog/Spring/PropertySourceConfigurer.html" class="sidebar-link">애너테이션을 사용하지 않고 PropertySource 등록하기</a></li><li><a href="/blog/Spring/Scheduler.html" class="sidebar-link">스프링 TaskScheduler(@EnableScheduling, @Scheduled)</a></li><li><a href="/blog/Spring/SpringBoot_Custom_Config_Properties.html" class="sidebar-link">SpringBoot Type-Safe하게 Property 설정하기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Vue/N1VuePressCh1.html" class="sidebar-link">VuePress로 블로그 제작 1 시작하기</a></li><li><a href="/blog/Vue/N2VuePressCh2.html" class="sidebar-link">VuePress로 블로그 제작 2 배포하기</a></li><li><a href="/blog/Vue/vuexModuleAutoRegister.html" class="sidebar-link">Vuex 모듈 등록 자동화하기</a></li></ul></section></li></ul> </aside> <aside class="rightbar" data-v-40a14b8c><div class="pr-2" data-v-689e6835 data-v-40a14b8c><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#결함과-부분-장애" class="rightbar-link" data-v-689e6835>
      결함과 부분 장애
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#신뢰성-없는-구성-요소를-사용해-신뢰성-있는-시스템-구축한-예" class="rightbar-link" data-v-689e6835>
      신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템 구축한 예
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#신뢰성-없는-네트워크" class="rightbar-link" data-v-689e6835>
      신뢰성 없는 네트워크
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#현실의-네트워크-결함" class="rightbar-link" data-v-689e6835>
      현실의 네트워크 결함
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#타임아웃과-기약-없는-지연" class="rightbar-link" data-v-689e6835>
      타임아웃과 기약 없는 지연
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#동기-네트워크-vs-비동기-네트워크" class="rightbar-link" data-v-689e6835>
      동기 네트워크 vs 비동기 네트워크
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#신뢰성-없는-시계" class="rightbar-link" data-v-689e6835>
      신뢰성 없는 시계
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#일-기준-시계-대-단조-시계" class="rightbar-link" data-v-689e6835>
      일 기준 시계 대 단조 시계
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#시계-동기화와-정확도" class="rightbar-link" data-v-689e6835>
      시계 동기화와 정확도
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#지식-진실-그리고-거짓말" class="rightbar-link" data-v-689e6835>
      지식, 진실, 그리고 거짓말
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#진실은-다수결로-결정된다" class="rightbar-link" data-v-689e6835>
      진실은 다수결로 결정된다
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#리더와-잠금" class="rightbar-link" data-v-689e6835>
      리더와 잠금
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#펜싱-토큰" class="rightbar-link" data-v-689e6835>
      펜싱 토큰
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#비잔틴-결함" class="rightbar-link" data-v-689e6835>
      비잔틴 결함
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html#정리" class="rightbar-link" data-v-689e6835>
      정리
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></aside> <main class="page"><div class="block content-title" data-v-73713578 data-v-fa8c0460><div style="width: 100%" data-v-73713578><div class="w-11/12 mx-auto title" data-v-73713578><h1 class="title" data-v-73713578>데이터 중심 애플리케이션 설계 Ch 8. 분산 시스템의 골칫거리</h1></div> <div class="text--primary text-right w-95 mr-5 my-2" data-v-73713578>
      작성일: 2021-12-16 22:23
    </div> <div class="w-100 text-center" data-v-73713578><!----></div> <hr class="content-divider" data-v-73713578></div></div> <div class="theme-default-content content__default"><h2 id="결함과-부분-장애"><a href="#결함과-부분-장애" class="header-anchor">#</a> 결함과 부분 장애</h2> <p>분산 시스템에서 시스템이 커질수록 구성 요소 중 하나가 고장날 가능성도 높다. 수천 개의 노드가 있는 시스템은 항상 뭔가 고장난 상태라고 가정하는게 합리적이다.</p> <p>소프트웨어 운영자로서 결함이 발생하면 소프트웨어가 어떻게 동작하는지 알아야 한다. 최선의 상황을 바라기만 하는 것은 현명하지 못하다. 분산 시스템에서 의심, 비관주의, 편집증은 그 값어치를 한다.</p> <p>분산 시스템이 동작하게 만드려면 부분 장애 가능성을 항상 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다. 즉, <strong>신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야 한다.</strong></p> <h3 id="신뢰성-없는-구성-요소를-사용해-신뢰성-있는-시스템-구축한-예"><a href="#신뢰성-없는-구성-요소를-사용해-신뢰성-있는-시스템-구축한-예" class="header-anchor">#</a> 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템 구축한 예</h3> <ul><li>이러한 시스템의 대표적인 예로 신뢰성 없는 IP(Internet Protocol)위에 신뢰성 높은 TCP(Transimission Control Protocal)를 두어 패킷 손실 시 재전송하고 순서에 맞춰 재조립되도록 보장해준다.</li></ul> <h2 id="신뢰성-없는-네트워크"><a href="#신뢰성-없는-네트워크" class="header-anchor">#</a> 신뢰성 없는 네트워크</h2> <p>여기서 다루는 분산 시스템은 <strong>비공유 시스템</strong>, 즉 네트워크로 연결된 다수의 장비로 네트워크가 이 장비들의 유일한 통신 수단이다.</p> <p>인터넷과 데이터센터 내부 이더넷은 비동기 패킷 네트워크다. 즉, <strong>노드는 다른 노드로 메시지(패킷)을 보낼 수 있지만 네트워크는 메시지가 언제 도착할 것인지 보장하지 않는다.</strong></p> <p><strong>요청을 보내고 응답을 기다릴 때 잘못될 수 있는 경우는 많다.</strong></p> <ol><li>요청이 손실됨(네트워크 케이블 뽑힘)</li> <li>요청이 큐에서 대기하다가 나중에 전송됨(네트워크나 수신자에 과부하)</li> <li>원격 노드에 장애(노드가 죽음)</li> <li>원격 노드의 일시적인 중지(GC)</li> <li>원격 노드가 요청을 처리했지만 응답이 네트워크에서 손실</li> <li>원격 노드가 요청을 처리했지만 응답이 지연</li></ol> <p><strong>전송 측은 패킷이 전송됐는지 아닌지조차 구별할 수 없다. 유일한 정보는 응답을 아직 받지 못했다는 것이다.</strong></p> <ul><li>이런 문제를 다루는 대표적인 방법은 <code>타임아웃</code>을 활용하여 응답이 도착하지 않았음을 가정한다.</li></ul> <h3 id="현실의-네트워크-결함"><a href="#현실의-네트워크-결함" class="header-anchor">#</a> 현실의 네트워크 결함</h3> <ul><li>누구도 네트워크 문제에서 자유로울 수 없다. 상어가 해저 케이블을 물어뜯어서 손상시키기도 한다.</li> <li>시스템 환경에서 네트워크 결함이 드물더라도 <strong>일어날 수 있다</strong>는 사실은 소프트웨어가 이를 처리할 수 있어야 한다는 뜻이다.</li></ul> <h4 id="결함-감지"><a href="#결함-감지" class="header-anchor">#</a> 결함 감지</h4> <ul><li>많은 시스템은 결함 있는 노드를 자동으로 감지할 수 있어야 한다.
<ul><li>로드 밸런서는 죽은 노드로 요청을 보내면 안된다.</li> <li>단일 리더 복제를 사용하는 분산 데이터베이스 시스템에서 리더에 장애가 발생하면 팔로워 중 하나가 리더로 승격돼야 한다.</li></ul></li> <li>하지만, <strong>불행하게도 네트워크에 관한 불확실성 때문에 노드가 동작 중인지 아닌지 구별하기 어렵다.</strong> <ul><li>TCP가 패킷이 전달됐다는 확인 응답을 했더라도 애플리케이션이 그것을 처리하기 전에 죽을 수도 있다.</li> <li>몇 번 재시도를 해 보고 타임아웃이 게속 발생하면 마침내 노드가 죽었다고 선언할 수 있다.</li></ul></li></ul> <h3 id="타임아웃과-기약-없는-지연"><a href="#타임아웃과-기약-없는-지연" class="header-anchor">#</a> 타임아웃과 기약 없는 지연</h3> <ul><li>타임아웃으로 결함을 감지할 수 있다면 타임아웃은 얼마나 길어야 할까?</li> <li>타임아웃이 길면 노드가 죽었다고 선언될 떄 까지 기다리는 시간이 길어진다.</li> <li>타임아웃이 짧은면 결함을 빨리 발견하지만 노드가 과부화로 인해 일시적으로 느려졌을때에도 죽었다고 잘못 판단할 위험이 있다.
<ul><li><strong>성급하게 노드가 죽었다고 선언하면 같은 동작이 여러번 수행될 수 있다.</strong></li> <li>만약 과부하로 인해 노드가 죽었다고 잘못 판단하는 경우 리밸런싱 과정은 더욱 더 상태를 악화시킬 수 있다.</li></ul></li> <li><strong>고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시간과 그들의 변동성을 측정해 유동적으로 타임아웃을 조절하게 하는 것이 좋다.</strong></li></ul> <h4 id="tcp-vs-udp"><a href="#tcp-vs-udp" class="header-anchor">#</a> TCP vs UDP</h4> <ul><li>TCP는 패킷이 손실되면 자동으로 재전송을 시도한다.
<ul><li>애플리케이션에서는 이를 모르지만 그 결과로 생긴 지연으로 판단할 수 있다.</li></ul></li> <li>UDP는 흐름 제어를 하지 않고 손실된 패킷을 재전송하지 않는다. 네트워크 지연이 크게 변하게 하는 원인 중 일부를 제거한다.
<ul><li><strong>그러므로, UDP는 지연된 데이터의 가치가 없는 상황에 선택하면 좋다.</strong></li> <li>화상 회의나 인터넷 전화는 지연된 데이터의 가치가 없기 때문에 UDP를 사용한다.</li></ul></li></ul> <h3 id="동기-네트워크-vs-비동기-네트워크"><a href="#동기-네트워크-vs-비동기-네트워크" class="header-anchor">#</a> 동기 네트워크 vs 비동기 네트워크</h3> <ul><li>동기식 네트워크의 대표적인 예시는 전화 네트워크이다. 전화 네트워크는 극단적인 신뢰성을 가진다.
<ul><li>전화 네트워크에서 통화할 때는 회선(circuit)이 만들어지며 통화가 끝날 때 까지 유지된다.</li> <li>동기식 네트워크는 이미 특정 공간만큼의 회선이 할당되어 있기 때문에 데이터가 여러 라우터를 거치더라도 큐 대기 문제를 겪지 않는다.</li></ul></li> <li>동기식 네트워크와 같이 회선을 할당하는 방식은 통화와 같은 초당 전송하는 비트 수가 고정되어 있는 경우 회선이 적절하지만 <strong>웹 페이지 요청과 같이 순간적으로 몰릴 수 있는 데이터 전송</strong>에 효율적이지 못하다.</li> <li>비동기 네트워크의 대표적인 예시는 인터넷이다. 인터넷은 대역폭을 <strong>동적으로 공유한다.</strong> <ul><li>전송적은 가능하면 빨리 패킷을 보내기 위해 서러 밀치며 네트워크 스위치가 빈번하게 어떤 패킷을 보낼지(대역폭을 할당할지) 결정한다. 이 방법은 <strong>큐 대기가 생길 수 있지만 선로를 효율적으로 이용할 수 있다.</strong></li> <li>이 방식은 자원을 최대한 효율적으로 사용한다. 하지만 지연이라는 큰 변동이 생기게 된다.</li> <li>통화와 같이 회선을 점유하는 방식은 해당 회선이 점유한 대역폭만큼을 계속 보유하기 때문에 실제 대역폭 만큼 데이터를 전송하지 않더라도 대역폭은 게속 할당된다. 대신 지연의 변동은 적다.</li></ul></li></ul> <h2 id="신뢰성-없는-시계"><a href="#신뢰성-없는-시계" class="header-anchor">#</a> 신뢰성 없는 시계</h2> <p>네트워크에 있는 개별 장비는 자신의 시계를 갖고 있다. 이 장치는 완변히 정확하지 않아서 각 장비는 자신만의 시간 개념이 있으며 이는 다른 장비보다 약간 빠를 수도 느릴 수도 있다.</p> <h3 id="일-기준-시계-대-단조-시계"><a href="#일-기준-시계-대-단조-시계" class="header-anchor">#</a> 일 기준 시계 대 단조 시계</h3> <ul><li>현대 컴퓨터는 최소 두 가지 종류의 시계를 갖고 있다. <strong>일 기준 시계(time-of-day clock)와 단조 시계(monotinic clock)다.</strong></li></ul> <h4 id="_1-일-기준-시계"><a href="#_1-일-기준-시계" class="header-anchor">#</a> 1) 일 기준 시계</h4> <ul><li>일 기준 시계는 벽시계 시간이라고도 하며 현재 날짜와 시간을 반환한다.
<ul><li>Java의 <code>System.currentTimeMillis()</code>는 epoch이래로 흐른 밀리초를 반환한다.</li></ul></li> <li><strong>일 기준 시계는 보통 NTP로 동기화된다.</strong> <ul><li>NTP로 동기화를 하더라도 네트워크 지연이 있기 때문에 모든 분산시스템에서 완벽히 동일한 일 기준 시계를 가지는건 불가능하다.</li></ul></li></ul> <h4 id="_2-단조-시계"><a href="#_2-단조-시계" class="header-anchor">#</a> 2) 단조 시계</h4> <ul><li>단조 시계는 항상 앞으로만 흐르는 시계로 컴퓨터 별로 고유한 값을 가진다.
<ul><li>Java의 <code>System.nanoTime()</code>가 대표적인 예다.</li> <li>컴퓨터 별로 고유하기 때문에 다른 컴퓨터의 단조 시계와 비교하는건 의미가 없다.</li></ul></li> <li>단조 시계는 타임아웃이나 서비스 응답 시간 같은 지속 시간과 같이 두 시점 사이에 흐른 시간이 얼마인지 재는 데 적합하다.</li> <li>로컬 시계가 NTP보다 빠르거나 느릴 때 단조 시계가 진행하는 진도수를 조정할 순 있지만 <strong>단조 시계가 앞이나 뒤로 뛰게 할 수는 없다.</strong></li> <li><strong>단조 시계의 해상도는 보통 상당히 좋기 때문에 분산 시스템에서 경과 시간을 재는 데 단조 시계를 쓰는 것이 일반적으로 좋다.</strong></li></ul> <h3 id="시계-동기화와-정확도"><a href="#시계-동기화와-정확도" class="header-anchor">#</a> 시계 동기화와 정확도</h3> <ul><li>하드웨어 시계와 NTP의 시계는 정확하지 않다. 다양한 사례로 시계의 정확도가 어긋날 수 있다.
<ul><li>장비의 온도에 따라 하드웨어 시계에 영향을 줄 수 있다.</li> <li>NTP 서버와의 지연으로 인해 오차가 발생할 수 있다.</li></ul></li> <li>카산드라는 충돌 해소 전략으로 <code>최종 쓰기 승리(LWW)</code>를 사용하는데 시계는 정확하지 않기 때문에 이로 인해 문제가 발생할 수도 있다.
<ul><li>가장 최근 값을 유지한다 하더라도 결국 <strong>최근의 정의는 로컬 일 기준 시계에 의존하기 때문에 완벽히 정확할 수 없다는 것을 아는게 중요하다.</strong></li></ul></li></ul> <h4 id="신뢰-구간을-활용한-순서-보장"><a href="#신뢰-구간을-활용한-순서-보장" class="header-anchor">#</a> 신뢰 구간을 활용한 순서 보장</h4> <ul><li>분산 시스템에서 각 시스템별로 시간차를 보장할 수 있는 신뢰 구간이 있다면 이를 통해 순서를 보장할 수 있다.
<ul><li>신뢰 구간이 5ms이고 A작업이 1ms에 시작됐고 B작업이 7ms에 시작됐다고하면 A작업은 B작업보다 빠른 시점에 수행되었음을 확신할 수 있다.</li> <li>이런식으로 순서를 보장하기 위해선 신뢰 구간까지 기다려야 하기 떄문에 신뢰 구간을 최대한 짧게 유지하는 것이 중요하다.</li></ul></li></ul> <h2 id="지식-진실-그리고-거짓말"><a href="#지식-진실-그리고-거짓말" class="header-anchor">#</a> 지식, 진실, 그리고 거짓말</h2> <h3 id="진실은-다수결로-결정된다"><a href="#진실은-다수결로-결정된다" class="header-anchor">#</a> 진실은 다수결로 결정된다</h3> <ul><li>분산 시스템은 한 노드에만 의존할 수 없다. 노드는 언제든 장애가 나서 잠재적으로 시스템이 멈추고 복구할 수 없게 될 수 있다. 각 노드는 자신의 판단을 믿을 수 없다.</li> <li>대신 여러 분산 알고리즘은 정족수를 활용한다.
<ul><li>정족수는 노드가 죽었다고 선언하는 것에 관한 결정에서도 사용된다.</li> <li>정족수를 이룬 노드들이 다른 노드를 죽었다고 선언하면 그 노드는 여전히 살아있을지 몰라도 죽었다고 간주되어야 한다.</li></ul></li></ul> <h3 id="리더와-잠금"><a href="#리더와-잠금" class="header-anchor">#</a> 리더와 잠금</h3> <ul><li>리더와 잠금을 분산 시스템에서 구현하려면 주의해야 한다.
<ul><li>어떤 노드가 이전에 리더였더라도 네트워크가 잠시 중단되었을 뿐 실제로 그 노드가 살아있음에도 불구하고 다른 노드가 그 노드를 죽었다고 선언해 새로운 리더를 선출했을 수도 있다.</li></ul></li></ul> <img src="/blog/assets/img/lock-issue.be7d6c04.png"> <ul><li>위 예시는 잠금을 잘못 구현해서 생긴 데이터 오염 버그를 보여준다.</li> <li>클라이언트 1이 임차권을 획득하고 stop-the-world로 중단이 되었을 때 임차권이 만료되어 클라이언트 2가 쓰기를 수행했지만 클라이언트 1은 여전히 임차권을 보유했다고 잘못 판단하여 쓰기 충돌이 발생한다.</li></ul> <h3 id="펜싱-토큰"><a href="#펜싱-토큰" class="header-anchor">#</a> 펜싱 토큰</h3> <ul><li>위와 같은 문제를 해결하기 위한 단순한 기법으로 <code>펜싱(fencing)</code>기법이 있다.</li></ul> <img src="/blog/assets/img/lock-issue.be7d6c04.png"> <ul><li>잠금 서버가 잠금이나 임차권을 승인할 때 마다 값이 하나씩 증가하는 <code>펜싱 토큰</code>도 반환하다.</li> <li>클라이언트가 쓰기 요청을 보낼 때 자신의 현재 펜싱 토큰을 포함하도록 하여 이 토큰 값을 비교하여 쓰기를 수행하도록 판별할 수 있다.</li></ul> <h3 id="비잔틴-결함"><a href="#비잔틴-결함" class="header-anchor">#</a> 비잔틴 결함</h3> <ul><li>펜싱 토큰은 부주의에 의한 오류에 빠진 노드를 감지하고 차단할 수 있다. 그러나 노드가 고의로 시스템 보장을 무너뜨리려 한다면 가짜 펜싱 토큰을 보내기만 하면 된다.</li> <li><strong>보통 노드들이 신뢰성은 업을 수 있지만 정직하다고 가정하지만</strong> 노드가 거짓말을 할지도 모른다는 위험이 있다면 훨씬 더 어려워 진다.</li> <li>이러한 동작을 <code>비잔틴 결함</code>이라고 하며 이렇게 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 <code>비잔틴 장군 문제</code>라고 한다.
<ul><li>일부 노드가 오작동하고 악의적인 공격자가 네트워크를 방해하더라도 시스템이 계속 올바르게 동작한다면 비잔틴 내결함성을 지닌다고 한다.</li> <li>이런 관심사는 항공기와 같은 시스템에서 필요로 한다.</li></ul></li> <li>대부분의 서버 측 데이터 시스템에서는 조직이 모든 노드를 제어하고 관리하기 때문에 비잔틴 내결함성 솔루션을 배치하는 것은 실용적이지 못하다.</li> <li>비잔틴 내결함성은 중앙 권한 없는 피어투피어 네트워크에 더 적합하다.</li></ul> <h2 id="정리"><a href="#정리" class="header-anchor">#</a> 정리</h2> <p><strong>분산 시스템에서 나타날 수 있는 신뢰성 문제는 광범위 하다.</strong></p> <ul><li>네트워크로 패킷을 보내려고할 때 언제나 패킷이 손실되거나 지연될 수 있다. 응답도 손실되거나 지연될 수 있으므로 응답을 받지못하면 메시지가 잘 전달됐는지 확신할 수 없다.</li> <li>노드의 시계는 다른 노드의 시계와 심하게 맞지 않을 수 있고 시간이 갑자기 앞뒤로 뛸 수도 있다.</li> <li>프로세스는 실행 도중 어느 시점에서든지 상당한 시간동안 멈출 수 있고 다른 노드들에 의해 죽었다고 선언될 수 있으며 잠시 멈춘노드는 자신이 죽었다는걸 알지 못할 수도 있다.</li></ul> <p><strong>부분 실패가 생길 수 있다는 사실은 분산 시스템의 뚜렷한 특성이다.</strong></p> <ul><li>분산 시스템에서 우리는 구성 요소의 일부가 고장 나더라도 전체로서의 시스템은 계속 동작할 수 있도록 부분 실패에 대한 내성을 소프트웨어에 내장하려고 노력한다.</li> <li>정확한 메커니즘이 없어 원격 노드의 생존을 파악하기 위해 타임아웃을 사용하지만 노드의 일시적인 중단, 네트워크 장애로 인해 확신할 수 없다.</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html" class="prev">
        Ch 7. 트랜잭션
      </a></span> <span class="next"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch9.html">
        Ch 9. 일관성과 합의
      </a>
      →
    </span></p></div> <div data-v-0eb52d94 data-v-fa8c0460></div></main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.a8f3d420.js" defer></script><script src="/blog/assets/js/18.20581197.js" defer></script><script src="/blog/assets/js/2.6e22e42d.js" defer></script><script src="/blog/assets/js/3.48647491.js" defer></script><script src="/blog/assets/js/1.784377b9.js" defer></script><script src="/blog/assets/js/33.4e277b33.js" defer></script>
  </body>
</html>
