<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>데이터 중심 애플리케이션 설계 Ch 7. 트랜잭션 | BLOG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/img/favicon.svg">
    <meta name="description" content="">
    <meta name="google-site-verification" content="5Yx4T6uI30XHP7CaIBllI-z_pTFiIF9H73JCnPtoqu0">
    
    <link rel="preload" href="/blog/assets/css/0.styles.bc7bfdbb.css" as="style"><link rel="preload" href="/blog/assets/js/app.bbc72c80.js" as="script"><link rel="preload" href="/blog/assets/js/18.65eaa4cd.js" as="script"><link rel="preload" href="/blog/assets/js/2.712f2133.js" as="script"><link rel="preload" href="/blog/assets/js/3.fb632d5d.js" as="script"><link rel="preload" href="/blog/assets/js/1.829eabcf.js" as="script"><link rel="preload" href="/blog/assets/js/41.6e31b514.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.60a5b290.js"><link rel="prefetch" href="/blog/assets/js/11.54d7b058.js"><link rel="prefetch" href="/blog/assets/js/12.8f505e42.js"><link rel="prefetch" href="/blog/assets/js/13.dab12b38.js"><link rel="prefetch" href="/blog/assets/js/14.20683788.js"><link rel="prefetch" href="/blog/assets/js/15.a2f05afc.js"><link rel="prefetch" href="/blog/assets/js/16.5f7b2c31.js"><link rel="prefetch" href="/blog/assets/js/17.842d2663.js"><link rel="prefetch" href="/blog/assets/js/19.8a1fa51e.js"><link rel="prefetch" href="/blog/assets/js/20.c90cbaa5.js"><link rel="prefetch" href="/blog/assets/js/21.86b937b4.js"><link rel="prefetch" href="/blog/assets/js/22.5dcd3ba9.js"><link rel="prefetch" href="/blog/assets/js/23.b3085c77.js"><link rel="prefetch" href="/blog/assets/js/24.41e02205.js"><link rel="prefetch" href="/blog/assets/js/25.642273b8.js"><link rel="prefetch" href="/blog/assets/js/26.15c29f40.js"><link rel="prefetch" href="/blog/assets/js/27.23a3fbdc.js"><link rel="prefetch" href="/blog/assets/js/28.4542f3d6.js"><link rel="prefetch" href="/blog/assets/js/29.59c89f8e.js"><link rel="prefetch" href="/blog/assets/js/30.2818bae9.js"><link rel="prefetch" href="/blog/assets/js/31.0a130bb6.js"><link rel="prefetch" href="/blog/assets/js/32.b34a17b7.js"><link rel="prefetch" href="/blog/assets/js/33.86cd2625.js"><link rel="prefetch" href="/blog/assets/js/34.dda955c9.js"><link rel="prefetch" href="/blog/assets/js/35.add71691.js"><link rel="prefetch" href="/blog/assets/js/36.faf76197.js"><link rel="prefetch" href="/blog/assets/js/37.c84ae923.js"><link rel="prefetch" href="/blog/assets/js/38.3ecab137.js"><link rel="prefetch" href="/blog/assets/js/39.e2521529.js"><link rel="prefetch" href="/blog/assets/js/4.2e364c8b.js"><link rel="prefetch" href="/blog/assets/js/40.82ab0fe7.js"><link rel="prefetch" href="/blog/assets/js/42.8167fecf.js"><link rel="prefetch" href="/blog/assets/js/43.0886415c.js"><link rel="prefetch" href="/blog/assets/js/44.8a462e2c.js"><link rel="prefetch" href="/blog/assets/js/45.5b100788.js"><link rel="prefetch" href="/blog/assets/js/46.9c8a1263.js"><link rel="prefetch" href="/blog/assets/js/47.8bcb88fc.js"><link rel="prefetch" href="/blog/assets/js/48.12bc5de3.js"><link rel="prefetch" href="/blog/assets/js/49.23ab2876.js"><link rel="prefetch" href="/blog/assets/js/50.231b8599.js"><link rel="prefetch" href="/blog/assets/js/51.f20df7da.js"><link rel="prefetch" href="/blog/assets/js/52.b2e3abd5.js"><link rel="prefetch" href="/blog/assets/js/53.a6893760.js"><link rel="prefetch" href="/blog/assets/js/54.0ba1f515.js"><link rel="prefetch" href="/blog/assets/js/55.29f30120.js"><link rel="prefetch" href="/blog/assets/js/56.bf7abdf1.js"><link rel="prefetch" href="/blog/assets/js/57.aa2892ba.js"><link rel="prefetch" href="/blog/assets/js/58.10fc19fe.js"><link rel="prefetch" href="/blog/assets/js/59.16240e09.js"><link rel="prefetch" href="/blog/assets/js/6.65e7eb8e.js"><link rel="prefetch" href="/blog/assets/js/60.642a6336.js"><link rel="prefetch" href="/blog/assets/js/61.6bb93b84.js"><link rel="prefetch" href="/blog/assets/js/62.7b8f74f3.js"><link rel="prefetch" href="/blog/assets/js/63.e1e30188.js"><link rel="prefetch" href="/blog/assets/js/64.35394201.js"><link rel="prefetch" href="/blog/assets/js/65.2e0837c8.js"><link rel="prefetch" href="/blog/assets/js/66.7b297937.js"><link rel="prefetch" href="/blog/assets/js/67.e2c26b5e.js"><link rel="prefetch" href="/blog/assets/js/68.57fd2e08.js"><link rel="prefetch" href="/blog/assets/js/69.a11ff7d7.js"><link rel="prefetch" href="/blog/assets/js/7.359afe32.js"><link rel="prefetch" href="/blog/assets/js/8.27587600.js"><link rel="prefetch" href="/blog/assets/js/9.60a6027d.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.bc7bfdbb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-fa8c0460><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="BLOG" class="logo"> <span class="site-name can-hide">BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Cassandra</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Cassandra/Cassandra_Consistency_Level.html" class="sidebar-link">카산드라 Consistency Level</a></li><li><a href="/blog/Cassandra/Cassandra_Eventual_And_Strong_Consistency.html" class="sidebar-link">카산드라 Eventual consistency vs Strong consistency</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>ComputerScience</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ComputerScience/BehavioralDesignPattern.html" class="sidebar-link">디자인 패턴(행동 패턴)</a></li><li><a href="/blog/ComputerScience/CharacterEncoding.html" class="sidebar-link">문자열 인코딩</a></li><li><a href="/blog/ComputerScience/CleanArchitecture.html" class="sidebar-link">클린 아키텍처</a></li><li><a href="/blog/ComputerScience/CreationalDesignPattern.html" class="sidebar-link">디자인 패턴(생성 패턴)</a></li><li><a href="/blog/ComputerScience/StructuralDesignPattern.html" class="sidebar-link">디자인 패턴(구조 패턴)</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/" class="sidebar-heading clickable router-link-active open"><span>데이터 중심 애플리케이션 설계</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch1.html" class="sidebar-link">Ch 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch2.html" class="sidebar-link">Ch 2. 데이터 모델과 질의 언어</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch3.html" class="sidebar-link">Ch 3. 저장소와 검색</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch4.html" class="sidebar-link">Ch 4. 부호화와 발전</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch5.html" class="sidebar-link">Ch 5. 복제</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html" class="sidebar-link">Ch 6. 파티셔닝</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html" aria-current="page" class="active sidebar-link">Ch 7. 트랜잭션</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#acid" class="sidebar-link">ACID</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#원자성-atomicity" class="sidebar-link">원자성(Atomicity)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#일관성-consistency" class="sidebar-link">일관성(Consistency)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#격리성-isolation" class="sidebar-link">격리성(Isolation)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#지속성-durability" class="sidebar-link">지속성(Durability)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#다중-객체-연산-트랜잭선" class="sidebar-link">다중 객체 연산(트랜잭선)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#오류와-어보트-처리" class="sidebar-link">오류와 어보트 처리</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#완화된-격리-수준" class="sidebar-link">완화된 격리 수준</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_1-커밋-후-읽기-read-committed" class="sidebar-link">1. 커밋 후 읽기(read committed)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_2-스냅숏-격리" class="sidebar-link">2. 스냅숏 격리</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#갱신-손실-방지" class="sidebar-link">갱신 손실 방지</a></li></ul></li></ul></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html" class="sidebar-link">Ch 8. 분산 시스템의 골칫거리</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Groovy</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Groovy/spock-summary.html" class="sidebar-link">Spock 사용 시 주의해야 할 것들</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Java/EffectiveJava.html" class="sidebar-link">Effective Java 3/E 정리</a></li><li><a href="/blog/Java/UseThreadLocalWhenAsyncCall.html" class="sidebar-link">비동기 호출 시 ThreadLocal 값 유지하기</a></li><li><a href="/blog/Java/awsEc2InstallJDK11.html" class="sidebar-link">AWS EC2에 JDK 11 설치하기</a></li><li><a href="/blog/Java/javaCodingSkill.html" class="sidebar-link">자바 코딩의 기술 정리</a></li><li><a href="/blog/Java/javaOverloadingParameter.html" class="sidebar-link">JAVA 매개변수(Parameter)수가 같은 오버로딩 메서드가 위험한 이유</a></li><li><a href="/blog/Java/resilience4j.html" class="sidebar-link">resilience4j Circuit Breaker</a></li><li><a href="/blog/Java/threadPoolExecutor.html" class="sidebar-link">Java의 ThreadPoolExecutor, Spring의 ThreadPoolTaskExecutor</a></li><li><a href="/blog/Java/whyCantCreateGenericsArray.html" class="sidebar-link">JAVA 제네릭 배열을 생성하지 못하는 이유</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Kotlin</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Kotlin/Coroutines.html" class="sidebar-link">코틀린 코루틴(Coroutine)</a></li><li><a href="/blog/Kotlin/ScopeFunctions.html" class="sidebar-link">코틀린 Scope functions(let, with, run, apply, also)</a></li><li><a href="/blog/Kotlin/kotlinInAction.html" class="sidebar-link">코틀린 인 액션 정리</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Network</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Network/HttpNetworkBasic.html" class="sidebar-link">그림으로 배우는 Http Network Basic 정리</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Spring</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Spring/DI_IOC.html" class="sidebar-link">Java, Spring 의존성 주입(DI), 제어의 역전(IoC)</a></li><li><a href="/blog/Spring/MockMvc_Encoding.html" class="sidebar-link">MockMvc 한글 깨짐 현상</a></li><li><a href="/blog/Spring/PropertySourceConfigurer.html" class="sidebar-link">애너테이션을 사용하지 않고 PropertySource 등록하기</a></li><li><a href="/blog/Spring/Scheduler.html" class="sidebar-link">스프링 TaskScheduler(@EnableScheduling, @Scheduled)</a></li><li><a href="/blog/Spring/SpringBoot_Custom_Config_Properties.html" class="sidebar-link">SpringBoot Type-Safe하게 Property 설정하기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Vue/N1VuePressCh1.html" class="sidebar-link">VuePress로 블로그 제작 1 시작하기</a></li><li><a href="/blog/Vue/N2VuePressCh2.html" class="sidebar-link">VuePress로 블로그 제작 2 배포하기</a></li><li><a href="/blog/Vue/vuexModuleAutoRegister.html" class="sidebar-link">Vuex 모듈 등록 자동화하기</a></li></ul></section></li></ul> </aside> <aside class="rightbar" data-v-40a14b8c><div class="pr-2" data-v-689e6835 data-v-40a14b8c><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#acid" class="rightbar-link" data-v-689e6835>
      ACID
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#원자성-atomicity" class="rightbar-link" data-v-689e6835>
      원자성(Atomicity)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#일관성-consistency" class="rightbar-link" data-v-689e6835>
      일관성(Consistency)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#격리성-isolation" class="rightbar-link" data-v-689e6835>
      격리성(Isolation)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#지속성-durability" class="rightbar-link" data-v-689e6835>
      지속성(Durability)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#다중-객체-연산-트랜잭선" class="rightbar-link" data-v-689e6835>
      다중 객체 연산(트랜잭선)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#오류와-어보트-처리" class="rightbar-link" data-v-689e6835>
      오류와 어보트 처리
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#완화된-격리-수준" class="rightbar-link" data-v-689e6835>
      완화된 격리 수준
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_1-커밋-후-읽기-read-committed" class="rightbar-link" data-v-689e6835>
      1. 커밋 후 읽기(read committed)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_2-스냅숏-격리" class="rightbar-link" data-v-689e6835>
      2. 스냅숏 격리
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#갱신-손실-방지" class="rightbar-link" data-v-689e6835>
      갱신 손실 방지
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div></div></aside> <main class="page"><div class="block content-title" data-v-73713578 data-v-fa8c0460><div style="width: 100%" data-v-73713578><div class="w-11/12 mx-auto title" data-v-73713578><h1 class="title" data-v-73713578>데이터 중심 애플리케이션 설계 Ch 7. 트랜잭션</h1></div> <div class="text--primary text-right w-95 mr-5 my-2" data-v-73713578>
      작성일: 2021-11-30 00:21
    </div> <div class="w-100 text-center" data-v-73713578><!----></div> <hr class="content-divider" data-v-73713578></div></div> <div class="theme-default-content content__default"><p>트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.</p> <p>트랜잭션을 쓰면 애플리케이션에서 오류 처리를 하기가 훨씬 단순해진다. 어떤 연산은 성공하고 어떤 연산은 실패하는 경우 처럼 부분적인 실패를 걱정할 필요가 없기 때문이다.</p> <h2 id="acid"><a href="#acid" class="header-anchor">#</a> ACID</h2> <p>트랜잭션이 제공하는 안전성 보장은 흔히 <strong>원자성(Atomicity)</strong>, <strong>일관성(Consistency)</strong>, <strong>격리성(Isolation)</strong>, **지속성(Durability)**을 위미하는 약어인 <code>ACID</code>로 잘 알려져 있다.</p> <h3 id="원자성-atomicity"><a href="#원자성-atomicity" class="header-anchor">#</a> 원자성(Atomicity)</h3> <p>여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶이고 트랜잭션은 <code>완료(커밋)</code>되거나 결함 발생 시 해당 트랜잭션의 모든 쓰기 작업이<code>중단(어보트)</code>되거나 둘 중 하나여야 한다.</p> <p><strong>오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력이 ACID의 원자성의 결정적인 특성이다.</strong></p> <h3 id="일관성-consistency"><a href="#일관성-consistency" class="header-anchor">#</a> 일관성(Consistency)</h3> <p><code>일관성</code>이라는 단어는 여러 의미로 사용된다.</p> <ul><li>eventual consistency, strong consistency에서는 복제 시스템간의 데이터 동기화에 대한 것이다.</li> <li>consistent hashing(일관성 해싱)에서는 시스템들의 재균형화를 위한 파티셔닝 방법이다.</li> <li>CAP 정리에서의 Consistency는 선형성을 의미한다.(ch9 참고)</li> <li><strong>ACID에서의 Consistency는 트랜잭션이 완료될 때 데이터에 관한 <code>불변식</code>이 반드시 만족되어야 하는 특성을 의미한다.</strong></li></ul> <p><strong>ACID에서의 일관성은 애플리케이션의 <code>불변식</code> 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션이 책임이다.</strong></p> <ul><li>유일성 조건 및 외래 키 조건과 같이 데이터베이스에서 확인할 수 있는 불변식이 존재하긴 하지만 이외의 불변식은 애플리케이션에서 정의하며 이 불변식을 데이터베이스에서 검증할 수 없다.</li> <li>ACID에서 일관성만 유일하게 애플리케이션의 속성이며 나머지는 모두 데이터베이스 속성이다.</li></ul> <h3 id="격리성-isolation"><a href="#격리성-isolation" class="header-anchor">#</a> 격리성(Isolation)</h3> <p>동시에 실행되는 트랜잭션은 서로 격리되어야 한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다.</p> <h3 id="지속성-durability"><a href="#지속성-durability" class="header-anchor">#</a> 지속성(Durability)</h3> <p>트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않고 지속되어야 한다.</p> <ul><li>지속석을 보장하기 위해서 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때 까지 기다려야 한다.</li> <li>완벽한 지속성은 보장할 수 없다. 모든 하드디스크와 백업이 동시에 파괴되면 데이터베이스가 해줄 수 있는건 없다.</li></ul> <h3 id="다중-객체-연산-트랜잭선"><a href="#다중-객체-연산-트랜잭선" class="header-anchor">#</a> 다중 객체 연산(트랜잭선)</h3> <p>다중 객체 연산을 위해서는 읽기 및 쓰기 연산들이 동일한 트랜잭션에 속하는지 알아야하고 이를 위해 관계형 데이터베이스에서는 TCP 연결 기반으로 BEGIN TRANSACTION문, COMMIT문 등을 통해 확인한다.</p> <p><strong>반면 비관계형 데이터베이스는 구현의 복잡성과 매우 높은 가용성 및 성능을 위해 이런 방식을 지원하지 않는 경우가 많다.</strong></p> <h4 id="다중-객체-트랜잭션의-필요성"><a href="#다중-객체-트랜잭션의-필요성" class="header-anchor">#</a> 다중 객체 트랜잭션의 필요성</h4> <ul><li>단일 객체 트랜잭션 만으로 충분한 사용 사례가 있지만 많은 경우에 다중 객체 트랜잭션이 필요하다.
<ol><li>서로 첨조하는 여러 레코드를 삽입할 때 참조 키는 항상 올라르고 최신 정보를 반영해야 한다.</li> <li>비정규화된 여러 테이블의 데이터들을 한 번에 갱신해야 한다.</li> <li>보조 색인이 있는 경우 값이 변경될 때 색인도 함께 갱신되어야 한다.</li></ol></li></ul> <h3 id="오류와-어보트-처리"><a href="#오류와-어보트-처리" class="header-anchor">#</a> 오류와 어보트 처리</h3> <p><strong>트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.</strong></p> <p>어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이니만 완벽하지 않다.</p> <ul><li>트랜잭션이 실제론 커밋되었지만 네트워크 문제로 클라이언트는 실패했다고 생각하여 중복 처리가 될 수 있다.</li> <li>오류가 과부하 때문이라면 재시도는 더 큰 문제를 만들 수 있다.</li> <li>일시적인 오류(데드락, 네트워크 오류, 시스템 장애)만 가치있고 영구적인 오류(제약 조건 위반)는 재시도해도 소용이 없다.</li></ul> <h2 id="완화된-격리-수준"><a href="#완화된-격리-수준" class="header-anchor">#</a> 완화된 격리 수준</h2> <p>트랜잭션이 직렬적으로 실행되는 직렬성 격리는 성능 비용이 크기 때문에 많은 데이터베이스는 그 비용을 지불하려고 하지 않는다. 따라서 완화된 격리 수준을 사용하는 시스템들이 흔하다.</p> <p>완화된 격리 수준은 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는다. 각 수준별 특성을 파악하여 애플리케이션에 적합한 격리 수준을 선택할 수 있게 하자.</p> <h3 id="_1-커밋-후-읽기-read-committed"><a href="#_1-커밋-후-읽기-read-committed" class="header-anchor">#</a> 1. 커밋 후 읽기(read committed)</h3> <p>가장 기본적인 트랜잭션 격리 수준으로 다음 두 가지를 보장해준다.</p> <ol><li>데이터베이스에서 읽을 때 커밋된 데이터만 본다.(<code>더티 읽기</code>가 없음)</li> <li>데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.(<code>더티 쓰기</code>가 없음)</li></ol> <h4 id="더티-읽기-방지"><a href="#더티-읽기-방지" class="header-anchor">#</a> 더티 읽기 방지</h4> <ul><li>다른 트랜잭션에서 커밋되지 않은 데이터를 보는 경우를 <code>더티 읽기</code>라고 부른다.</li> <li>커밋 후 읽기 격리 수준에서는 더티 읽기를 막아야 한다.</li> <li>더티 읽기를 막는게 유용한 이유는 다음과 같다.
<ul><li>트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있게 된다.</li> <li>트랜잭션이 어보트되면 롤백해야 하는데 더티 읽기가 생기면 실제로 커밋되지 않은 롤백된 데이터를 볼 수 있게 된다.</li></ul></li></ul> <h4 id="더티-쓰기-방지"><a href="#더티-쓰기-방지" class="header-anchor">#</a> 더티 쓰기 방지</h4> <ul><li>아직 커밋되지 않은 트랜잭션에서 쓴 데이터를 새로운 트랜잭션이 덮어 쓰는 경우를 <code>더티 쓰기</code>라고 한다.
<ul><li>보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때 까지 두번째 쓰기를 지연시킨다.</li></ul></li> <li>커밋 후 읽기 격리 수준에서는 터티 쓰기를 막아야 한다.</li> <li>더티 쓰기를 막지 않으면 트랜잭션이 여러 객체를 갱신할 때 갱신 값들이 다른 트랜잭션과 뒤섞여 데이터에 문제가 발생할 수 있다.</li></ul> <h4 id="커밋-후-읽기-구현"><a href="#커밋-후-읽기-구현" class="header-anchor">#</a> 커밋 후 읽기 구현</h4> <ul><li>더티 쓰기의 경우 가장 흔한 방법으로 로우 수준 잠금을 사용해 방지한다.
<ul><li>트랜잭션에서 로우(객체)를 변경하고 싶다면 잠금을 획득해야 하고 오직 한 트랜잭션만 어떤 주어진 객체에 대해 잠금을 보유할 수 있다.</li></ul></li> <li>더티 읽기는 잠금을 사용하면 응답 시간에 많은 영향을 주기 때문에 <strong>데이터베이스는 모든 객체에 대해 과거에 커밋된 값과 현재 트랜잭션에서 쓴 새로운 값을 모두 기억한다.</strong> <ul><li>다른 트랜잭션은 현재 트랜잭션에서 커밋하기 전 까지는 과거에 커밋된 값을 읽게 된다.</li></ul></li></ul> <h4 id="커밋-후-읽기-에서는-막을-수-없는-비반복-읽기-nonrepeatable-read"><a href="#커밋-후-읽기-에서는-막을-수-없는-비반복-읽기-nonrepeatable-read" class="header-anchor">#</a> 커밋 후 읽기 에서는 막을 수 없는 비반복 읽기(nonrepeatable read)</h4> <ul><li>은행 계좌 A, B에 각각 500원 씩 있고 A -&gt; B로 100원을 송금 할 때 송금 트랜잭션이 처리되고 있는 순간에 계좌 잔고를 보면 A는 400원, B는 500원으로 나와 총 900원이 있는 것 처럼 나올 것이다.</li> <li>이런 현상을 비반복 읽기(읽기 스큐)라고 하며 커밋 후 읽기 에서는 이런 현상을 막을 수 없다.</li> <li>시간이 지나 트랜잭션이 커밋되면 이런 현상은 사라지지만 이런 일시적인 비일관성도 감내할 수 없는 경우가 있다.(대표적으로 백업이 있다.)</li></ul> <h3 id="_2-스냅숏-격리"><a href="#_2-스냅숏-격리" class="header-anchor">#</a> 2. 스냅숏 격리</h3> <p>스냅숏 격리는 비반복 읽기와 같은 문제를 해결할 수 있는 가장 흔한 해결책이다. 트랜잭션은 특정 시점에 고정된 데이터베이스의 일관된 스냅숏만을 볼 수 있다.</p> <p><strong>각 트랜잭션은 데이터베이스의 일관된 스냅숏으로 부터 읽는다.</strong> <strong>그러므로 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터만을 보게 된다.</strong></p> <p>스냅숏 격리는 PostgreSQL, InnoDB 엔진 기반의 MySQL, Oracle 등에서 지원한다.</p> <h4 id="스냅숏-격리-구현"><a href="#스냅숏-격리-구현" class="header-anchor">#</a> 스냅숏 격리 구현</h4> <ul><li><strong>스냅숏 격리를 구현하기 위해서는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다.</strong></li> <li>데이터베이스가 객체의 <strong>여러 버전을 함께 유지하는 기법을 다중 버전 동시성 제어(multi-version concurreny control, MVCC)라고 한다.</strong> <ul><li>스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다.(커밋된 버전과 아직 커밋되지 않은 버전 2가지로 커밋 후 읽기 격리를 구현할 수 있다.)</li></ul></li> <li>트랜잭션 별로 고유한 트랜잭션 ID를 할당받고 트랜잭션이 데이터를 쓸 때 마다 해당 트랜잭션 ID와 버전별 객체가 기록되어 트랜잭션에 따라 특정 버전의 객체들을 읽을 수 있도록 한다.</li></ul> <h4 id="반복-읽기-repeatable-read-스냅숏-격리"><a href="#반복-읽기-repeatable-read-스냅숏-격리" class="header-anchor">#</a> 반복 읽기(repeatable read) = 스냅숏 격리</h4> <ul><li>PostgreSQL, MySQL에서는 스냅숏 격리를 반복 읽기라고 한다.</li></ul> <h3 id="갱신-손실-방지"><a href="#갱신-손실-방지" class="header-anchor">#</a> 갱신 손실 방지</h3> <p>커밋 후 읽기와 스냅숏 격리는 주로 동시에 실행되는 쓰기 작업에서 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 보장과 관련된 것이다.</p> <p>하지만 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌 상황들이 존재하며 가장 유명한 것이 <strong>갱신 손실(lost update) 문제이다.</strong></p> <ul><li>갱신 손실 문제는 카운터와 같이 값을 읽고 변경한 후 변경된 값을 다시 써야할 때(read-modify-write) 여러 트랜잭션이 동시에 해당 작업은 수행하는 경우 발생할 수 있다.</li> <li>이 문제는 흔해서 다야한 해결책이 개발되었다.</li></ul> <h4 id="_1-원자적-쓰기-연산"><a href="#_1-원자적-쓰기-연산" class="header-anchor">#</a> 1) 원자적 쓰기 연산</h4> <ul><li>여러 데이터베이스에서 원자적 쓰기 연산을 제공하기 때문에 애플리케이션에서 read-modify-write 주기를 구현할 필요를 없애 준다.</li> <li><code>UPDATE counters SET value = value + 1 WHERE key = 'foo'</code> 이 쿼리는 대부분의 관계형 데이터베이스에서 동시성 안전하다.</li></ul> <h4 id="_2-명시적인-잠금"><a href="#_2-명시적인-잠금" class="header-anchor">#</a> 2) 명시적인 잠금</h4> <ul><li>데이터베이스에서 원자적 쓰기 연산을 제공하지 않는다면 애플리케이션에서 객체를 명시적으로 잠그는 방식으로 해결할 수 있다.</li> <li>MySQL의 경우 SELECT 시 <code>FOR UPDATE</code> 절을 활용하여 로우를 잠글 수 있다. 단, 명시적인 잠금 방식은 실수할 여지가 많다.</li></ul> <h4 id="_3-갱신-손실-자동-감지"><a href="#_3-갱신-손실-자동-감지" class="header-anchor">#</a> 3) 갱신 손실 자동 감지</h4> <ul><li>병렬 실행을 허용하도록 하고 갱신 손실을 자동 감지하여 발견 시 트랜잭션을 어보트 시키고 read-modify-write 주기를 재시도 하도록 강제하는 방법이 있다.</li> <li>이 기능은 명시적인 잠금을 실수로 빼먹었을 때 자동으로 갱신 손실을 감지하여 트랜잭션을 어보트 시킬 수 있기 때문에 유용하다.</li> <li>오라클, SQL 서버는 이 기능을 제공하지만 InnoDB 기반의 MySQL은 이 기능을 제공하지 않는다.</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html" class="prev">
        Ch 6. 파티셔닝
      </a></span> <span class="next"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html">
        Ch 8. 분산 시스템의 골칫거리
      </a>
      →
    </span></p></div> <div data-v-0eb52d94 data-v-fa8c0460></div></main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.bbc72c80.js" defer></script><script src="/blog/assets/js/18.65eaa4cd.js" defer></script><script src="/blog/assets/js/2.712f2133.js" defer></script><script src="/blog/assets/js/3.fb632d5d.js" defer></script><script src="/blog/assets/js/1.829eabcf.js" defer></script><script src="/blog/assets/js/41.6e31b514.js" defer></script>
  </body>
</html>
