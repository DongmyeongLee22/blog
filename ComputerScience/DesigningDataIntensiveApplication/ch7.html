<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>데이터 중심 애플리케이션 설계 Ch 7. 트랜잭션 | BLOG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/img/favicon.svg">
    <meta name="description" content="">
    <meta name="google-site-verification" content="5Yx4T6uI30XHP7CaIBllI-z_pTFiIF9H73JCnPtoqu0">
    
    <link rel="preload" href="/blog/assets/css/0.styles.3b93488b.css" as="style"><link rel="preload" href="/blog/assets/js/app.6f1e1328.js" as="script"><link rel="preload" href="/blog/assets/js/19.fd0cc71e.js" as="script"><link rel="preload" href="/blog/assets/js/2.771035c7.js" as="script"><link rel="preload" href="/blog/assets/js/3.b0b2c100.js" as="script"><link rel="preload" href="/blog/assets/js/1.b0de5fa9.js" as="script"><link rel="preload" href="/blog/assets/js/18.586c6123.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.f6712507.js"><link rel="prefetch" href="/blog/assets/js/11.4af514d9.js"><link rel="prefetch" href="/blog/assets/js/12.78bb1682.js"><link rel="prefetch" href="/blog/assets/js/13.0ed6c4e8.js"><link rel="prefetch" href="/blog/assets/js/14.639e7b7f.js"><link rel="prefetch" href="/blog/assets/js/15.0de5e673.js"><link rel="prefetch" href="/blog/assets/js/16.05dad999.js"><link rel="prefetch" href="/blog/assets/js/17.bbc637e4.js"><link rel="prefetch" href="/blog/assets/js/20.944ec4c3.js"><link rel="prefetch" href="/blog/assets/js/21.91d7aee9.js"><link rel="prefetch" href="/blog/assets/js/22.8c26b18d.js"><link rel="prefetch" href="/blog/assets/js/23.89b73bfd.js"><link rel="prefetch" href="/blog/assets/js/24.6cccc146.js"><link rel="prefetch" href="/blog/assets/js/25.5a8470c6.js"><link rel="prefetch" href="/blog/assets/js/26.272184c4.js"><link rel="prefetch" href="/blog/assets/js/27.008dc424.js"><link rel="prefetch" href="/blog/assets/js/28.dda24498.js"><link rel="prefetch" href="/blog/assets/js/29.e6307859.js"><link rel="prefetch" href="/blog/assets/js/30.876e7dc0.js"><link rel="prefetch" href="/blog/assets/js/31.f828c6c4.js"><link rel="prefetch" href="/blog/assets/js/32.0b22dd92.js"><link rel="prefetch" href="/blog/assets/js/33.3ede37c2.js"><link rel="prefetch" href="/blog/assets/js/34.f253ed78.js"><link rel="prefetch" href="/blog/assets/js/35.02d9a146.js"><link rel="prefetch" href="/blog/assets/js/36.9b793d8a.js"><link rel="prefetch" href="/blog/assets/js/37.ab6c649c.js"><link rel="prefetch" href="/blog/assets/js/38.2407eec0.js"><link rel="prefetch" href="/blog/assets/js/39.1efc826b.js"><link rel="prefetch" href="/blog/assets/js/4.c5f5dd73.js"><link rel="prefetch" href="/blog/assets/js/40.4536b67a.js"><link rel="prefetch" href="/blog/assets/js/41.acf86248.js"><link rel="prefetch" href="/blog/assets/js/42.2a72892e.js"><link rel="prefetch" href="/blog/assets/js/43.87af6ff5.js"><link rel="prefetch" href="/blog/assets/js/44.9da2a0d8.js"><link rel="prefetch" href="/blog/assets/js/45.993c6b9a.js"><link rel="prefetch" href="/blog/assets/js/46.0c610f41.js"><link rel="prefetch" href="/blog/assets/js/47.9b2c3147.js"><link rel="prefetch" href="/blog/assets/js/48.5b039d0e.js"><link rel="prefetch" href="/blog/assets/js/49.9d95b96e.js"><link rel="prefetch" href="/blog/assets/js/50.926d94bb.js"><link rel="prefetch" href="/blog/assets/js/51.94c5b3e2.js"><link rel="prefetch" href="/blog/assets/js/52.8e406319.js"><link rel="prefetch" href="/blog/assets/js/53.d5dc0d11.js"><link rel="prefetch" href="/blog/assets/js/54.f0d4b82a.js"><link rel="prefetch" href="/blog/assets/js/55.379a64ba.js"><link rel="prefetch" href="/blog/assets/js/56.7b9953ec.js"><link rel="prefetch" href="/blog/assets/js/57.042e5c11.js"><link rel="prefetch" href="/blog/assets/js/58.d2b6fea9.js"><link rel="prefetch" href="/blog/assets/js/59.f81e2290.js"><link rel="prefetch" href="/blog/assets/js/6.3964c54c.js"><link rel="prefetch" href="/blog/assets/js/60.365a9a6f.js"><link rel="prefetch" href="/blog/assets/js/61.2fcc2456.js"><link rel="prefetch" href="/blog/assets/js/62.17f9e0ac.js"><link rel="prefetch" href="/blog/assets/js/63.ebac3f6a.js"><link rel="prefetch" href="/blog/assets/js/64.bb8ea9e8.js"><link rel="prefetch" href="/blog/assets/js/65.ddd3c56f.js"><link rel="prefetch" href="/blog/assets/js/66.af07c7b6.js"><link rel="prefetch" href="/blog/assets/js/67.840401eb.js"><link rel="prefetch" href="/blog/assets/js/68.a69e9ef1.js"><link rel="prefetch" href="/blog/assets/js/69.3ac2fbf6.js"><link rel="prefetch" href="/blog/assets/js/7.370c848f.js"><link rel="prefetch" href="/blog/assets/js/70.ecbff64e.js"><link rel="prefetch" href="/blog/assets/js/71.d6a660ec.js"><link rel="prefetch" href="/blog/assets/js/72.c3429f6d.js"><link rel="prefetch" href="/blog/assets/js/73.4e333f13.js"><link rel="prefetch" href="/blog/assets/js/74.b0bb742f.js"><link rel="prefetch" href="/blog/assets/js/75.ed1cd426.js"><link rel="prefetch" href="/blog/assets/js/76.f5006d86.js"><link rel="prefetch" href="/blog/assets/js/77.7c83b86e.js"><link rel="prefetch" href="/blog/assets/js/78.99313a66.js"><link rel="prefetch" href="/blog/assets/js/79.eb85b349.js"><link rel="prefetch" href="/blog/assets/js/8.19049ea4.js"><link rel="prefetch" href="/blog/assets/js/80.2ef3746b.js"><link rel="prefetch" href="/blog/assets/js/9.8dd951e3.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.3b93488b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-fa8c0460><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="BLOG" class="logo"> <span class="site-name can-hide">BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/pompitzz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/pompitzz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>AWS</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/AWS/AWSCertifiedDeveloperAssociate.html" class="sidebar-link">AWS Certified Developer Associate(DVA-C01) 자격증 후기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Cassandra</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Cassandra/Cassandra_Consistency_Level.html" class="sidebar-link">카산드라 Consistency Level</a></li><li><a href="/blog/Cassandra/Cassandra_Eventual_And_Strong_Consistency.html" class="sidebar-link">카산드라 Eventual consistency vs Strong consistency</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>ComputerScience</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ComputerScience/BehavioralDesignPattern.html" class="sidebar-link">디자인 패턴(행동 패턴)</a></li><li><a href="/blog/ComputerScience/CharacterEncoding.html" class="sidebar-link">문자열 인코딩</a></li><li><a href="/blog/ComputerScience/CreationalDesignPattern.html" class="sidebar-link">디자인 패턴(생성 패턴)</a></li><li><a href="/blog/ComputerScience/StructuralDesignPattern.html" class="sidebar-link">디자인 패턴(구조 패턴)</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/" class="sidebar-heading clickable router-link-active open"><span>데이터 중심 애플리케이션 설계</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch1.html" class="sidebar-link">Ch 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch2.html" class="sidebar-link">Ch 2. 데이터 모델과 질의 언어</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch3.html" class="sidebar-link">Ch 3. 저장소와 검색</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch4.html" class="sidebar-link">Ch 4. 부호화와 발전</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch5.html" class="sidebar-link">Ch 5. 복제</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html" class="sidebar-link">Ch 6. 파티셔닝</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html" aria-current="page" class="active sidebar-link">Ch 7. 트랜잭션</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#acid" class="sidebar-link">ACID</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#원자성-atomicity" class="sidebar-link">원자성(Atomicity)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#일관성-consistency" class="sidebar-link">일관성(Consistency)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#격리성-isolation" class="sidebar-link">격리성(Isolation)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#지속성-durability" class="sidebar-link">지속성(Durability)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#다중-객체-연산-트랜잭션" class="sidebar-link">다중 객체 연산(트랜잭션)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#오류와-어보트-처리" class="sidebar-link">오류와 어보트 처리</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#완화된-격리-수준-weak-isolation-level" class="sidebar-link">완화된 격리 수준(Weak Isolation Level)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#커밋-후-읽기-read-committed" class="sidebar-link">커밋 후 읽기(read committed)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#스냅숏-격리-snapshot-isolation" class="sidebar-link">스냅숏 격리(Snapshot Isolation)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#갱신-손실-lost-update-방지" class="sidebar-link">갱신 손실(Lost Update) 방지</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#쓰기-스큐-write-skew-와-팬텀" class="sidebar-link">쓰기 스큐(write skew)와 팬텀</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#직렬성-serializability" class="sidebar-link">직렬성(Serializability)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_1-트랜잭션-직렬-실행" class="sidebar-link">1. 트랜잭션 직렬 실행</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_2-2단계-잠금-2pl" class="sidebar-link">2. 2단계 잠금(2PL)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_3-직렬성-스냅숏-격리-serializable-snapshot-isolation" class="sidebar-link">3. 직렬성 스냅숏 격리(Serializable Snapshot Isolation)</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#정리" class="sidebar-link">정리</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#acid-2" class="sidebar-link">ACID</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#격리-수준" class="sidebar-link">격리 수준</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#경쟁-조건-race-condition" class="sidebar-link">경쟁 조건(Race Condition)</a></li><li class="sidebar-sub-header"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#직렬성-격리-구현" class="sidebar-link">직렬성 격리 구현</a></li></ul></li></ul></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html" class="sidebar-link">Ch 8. 분산 시스템의 골칫거리</a></li><li><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch9.html" class="sidebar-link">Ch 9. 일관성과 합의</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Gradle</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Gradle/GradleCommands.html" class="sidebar-link">Gradle 명령어 모음</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Groovy</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Groovy/spock-summary.html" class="sidebar-link">Spock 사용 시 주의해야 할 것들</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Java/CircuitBreaker.html" class="sidebar-link">Circuit Breaker 패턴, resilience4j Circuit Breaker 살펴보기</a></li><li><a href="/blog/Java/CircuitBreakerSlidingWindowTypes.html" class="sidebar-link">resilience4j CircuitBreaker의 COUNTBASED, TIMEBASED 동작 방식 살펴보기</a></li><li><a href="/blog/Java/EffectiveJava.html" class="sidebar-link">Effective Java 3/E 정리</a></li><li><a href="/blog/Java/UseThreadLocalWhenAsyncCall.html" class="sidebar-link">비동기 호출 시 ThreadLocal 값 유지하기</a></li><li><a href="/blog/Java/awsEc2InstallJDK11.html" class="sidebar-link">AWS EC2에 JDK 11 설치하기</a></li><li><a href="/blog/Java/javaOverloadingParameter.html" class="sidebar-link">JAVA 매개변수(Parameter)수가 같은 오버로딩 메서드가 위험한 이유</a></li><li><a href="/blog/Java/jmh_and_asyncProfiler.html" class="sidebar-link">gradle에서 JMH 사용해보기, async profiler로 flamegraph 출력하기</a></li><li><a href="/blog/Java/threadPoolExecutor.html" class="sidebar-link">Java의 ThreadPoolExecutor, Spring의 ThreadPoolTaskExecutor</a></li><li><a href="/blog/Java/whyCantCreateGenericsArray.html" class="sidebar-link">JAVA 제네릭 배열을 생성하지 못하는 이유</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Kafka</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Kafka/KafkaCommands.html" class="sidebar-link">Kafka(카프카) CLI 명령어 모음</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Kotlin</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Kotlin/Coroutines.html" class="sidebar-link">코틀린 코루틴(Coroutine)</a></li><li><a href="/blog/Kotlin/ScopeFunctions.html" class="sidebar-link">코틀린 Scope functions(let, with, run, apply, also)</a></li><li><a href="/blog/Kotlin/kotlinInAction.html" class="sidebar-link">코틀린 인 액션 정리</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Redis</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Redis/LocalCacheSyncWithRedisPubSub.html" class="sidebar-link">Redis(Pub/Sub)로 로컬 캐시 동기화하기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Spring</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Spring/DI_IOC.html" class="sidebar-link">Java, Spring 의존성 주입(DI), 제어의 역전(IoC)</a></li><li><a href="/blog/Spring/MockMvc_Encoding.html" class="sidebar-link">MockMvc 한글 깨짐 현상</a></li><li><a href="/blog/Spring/PropertySourceConfigurer.html" class="sidebar-link">애너테이션을 사용하지 않고 PropertySource 등록하기</a></li><li><a href="/blog/Spring/RestTemplate_Timeout.html" class="sidebar-link">Spring RestTemplate의 ConnectionTimout vs ReadTimoeut</a></li><li><a href="/blog/Spring/Scheduler.html" class="sidebar-link">스프링 TaskScheduler(@EnableScheduling, @Scheduled)</a></li><li><a href="/blog/Spring/SpringBoot_Custom_Config_Properties.html" class="sidebar-link">SpringBoot Type-Safe하게 Property 설정하기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Vue/N1VuePressCh1.html" class="sidebar-link">VuePress로 블로그 제작 1 시작하기</a></li><li><a href="/blog/Vue/N2VuePressCh2.html" class="sidebar-link">VuePress로 블로그 제작 2 배포하기</a></li><li><a href="/blog/Vue/vuexModuleAutoRegister.html" class="sidebar-link">Vuex 모듈 등록 자동화하기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>etc</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/etc/ProgrammersBrain.html" class="sidebar-link">프로그래머의 뇌 서적 요약</a></li><li><a href="/blog/etc/VimCommands.html" class="sidebar-link">Vim 명령어 모음</a></li></ul></section></li></ul> </aside> <aside class="rightbar" data-v-40a14b8c><div class="pr-2" data-v-689e6835 data-v-40a14b8c><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#acid" class="rightbar-link" data-v-689e6835>
      ACID
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#원자성-atomicity" class="rightbar-link" data-v-689e6835>
      원자성(Atomicity)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#일관성-consistency" class="rightbar-link" data-v-689e6835>
      일관성(Consistency)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#격리성-isolation" class="rightbar-link" data-v-689e6835>
      격리성(Isolation)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#지속성-durability" class="rightbar-link" data-v-689e6835>
      지속성(Durability)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#다중-객체-연산-트랜잭션" class="rightbar-link" data-v-689e6835>
      다중 객체 연산(트랜잭션)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#오류와-어보트-처리" class="rightbar-link" data-v-689e6835>
      오류와 어보트 처리
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#완화된-격리-수준-weak-isolation-level" class="rightbar-link" data-v-689e6835>
      완화된 격리 수준(Weak Isolation Level)
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#커밋-후-읽기-read-committed" class="rightbar-link" data-v-689e6835>
      커밋 후 읽기(read committed)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#스냅숏-격리-snapshot-isolation" class="rightbar-link" data-v-689e6835>
      스냅숏 격리(Snapshot Isolation)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#갱신-손실-lost-update-방지" class="rightbar-link" data-v-689e6835>
      갱신 손실(Lost Update) 방지
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#쓰기-스큐-write-skew-와-팬텀" class="rightbar-link" data-v-689e6835>
      쓰기 스큐(write skew)와 팬텀
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#직렬성-serializability" class="rightbar-link" data-v-689e6835>
      직렬성(Serializability)
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_1-트랜잭션-직렬-실행" class="rightbar-link" data-v-689e6835>
      1. 트랜잭션 직렬 실행
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_2-2단계-잠금-2pl" class="rightbar-link" data-v-689e6835>
      2. 2단계 잠금(2PL)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#_3-직렬성-스냅숏-격리-serializable-snapshot-isolation" class="rightbar-link" data-v-689e6835>
      3. 직렬성 스냅숏 격리(Serializable Snapshot Isolation)
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#정리" class="rightbar-link" data-v-689e6835>
      정리
    </a> <div data-v-689e6835 data-v-689e6835><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#acid-2" class="rightbar-link" data-v-689e6835>
      ACID
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#격리-수준" class="rightbar-link" data-v-689e6835>
      격리 수준
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#경쟁-조건-race-condition" class="rightbar-link" data-v-689e6835>
      경쟁 조건(Race Condition)
    </a> <div data-v-689e6835 data-v-689e6835></div></div><div class="header" data-v-689e6835><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html#직렬성-격리-구현" class="rightbar-link" data-v-689e6835>
      직렬성 격리 구현
    </a> <div data-v-689e6835 data-v-689e6835></div></div></div></div></div></aside> <main class="page"><div class="block content-title" data-v-73713578 data-v-fa8c0460><div style="width: 100%" data-v-73713578><div class="w-11/12 mx-auto title" data-v-73713578><h1 class="title" data-v-73713578>데이터 중심 애플리케이션 설계 Ch 7. 트랜잭션</h1></div> <div class="text--primary text-right w-95 mr-5 my-2" data-v-73713578>
      작성일: 2021-11-30 00:21
    </div> <div class="w-100 text-center" data-v-73713578><!----></div> <hr class="content-divider" data-v-73713578></div></div> <div class="theme-default-content content__default"><p>트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.</p> <p>트랜잭션을 쓰면 애플리케이션에서 오류 처리를 하기가 훨씬 단순해진다. 어떤 연산은 성공하고 어떤 연산은 실패하는 경우처럼 부분적인 실패를 걱정할 필요가 없기 때문이다.</p> <h2 id="acid"><a href="#acid" class="header-anchor">#</a> ACID</h2> <p>트랜잭션이 제공하는 안전성 보장은 흔히 <strong>원자성(Atomicity)</strong>, <strong>일관성(Consistency)</strong>, <strong>격리성(Isolation)</strong>, <strong>지속성(Durability)</strong> 을 위미하는 약어인 <code>ACID</code>로 잘 알려져 있다.</p> <h3 id="원자성-atomicity"><a href="#원자성-atomicity" class="header-anchor">#</a> 원자성(Atomicity)</h3> <p>여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶이고 트랜잭션은 <code>완료(커밋)</code>되거나 결함 발생 시 해당 트랜잭션의 모든 쓰기 작업이<code>중단(어보트)</code>되거나 둘 중 하나여야 한다.</p> <p><strong>오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력이 ACID의 원자성의 결정적인 특성이다.</strong></p> <h3 id="일관성-consistency"><a href="#일관성-consistency" class="header-anchor">#</a> 일관성(Consistency)</h3> <p><code>일관성</code>이라는 단어는 여러 의미로 사용된다.</p> <ul><li>eventual/strong consistency에서는 복제 시스템간의 데이터 동기화에 대한 것이다.</li> <li>consistent hashing(일관성 해싱)에서는 시스템들의 재균형화를 위한 파티셔닝 방법이다.</li> <li>CAP 정리에서의 Consistency는 선형성(strong consistency)을 의미한다.(<a href="https://pompitzz.github.io/blog/ComputerScience/DesigningDataIntensiveApplication/ch9.html#cap-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5" target="_blank" rel="noopener noreferrer">ch9 참고<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</li> <li><strong>ACID에서의 Consistency는 트랜잭션이 완료될 때 데이터에 관한 <code>불변식</code>이 반드시 만족되어야 하는 특성을 의미한다.</strong></li></ul> <p><strong>ACID에서의 일관성은 애플리케이션의 <code>불변식</code> 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다.</strong></p> <ul><li>유일성 조건 및 외래 키 조건과 같이 데이터베이스에서 확인할 수 있는 불변식이 존재하긴 하지만 이외의 불변식은 애플리케이션에서 정의하며 이 불변식을 데이터베이스에서 검증할 수 없다.</li> <li><strong>ACID에서 일관성만 유일하게 애플리케이션의 속성이다.</strong> 나머지는 모두 데이터베이스 속성이다.</li></ul> <h3 id="격리성-isolation"><a href="#격리성-isolation" class="header-anchor">#</a> 격리성(Isolation)</h3> <p>동시에 실행되는 트랜잭션은 서로 격리되어야 한다. <strong>트랜잭션은 다른 트랜잭션을 방해할 수 없다.</strong></p> <h3 id="지속성-durability"><a href="#지속성-durability" class="header-anchor">#</a> 지속성(Durability)</h3> <p>트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 <strong>트랜잭션에서 기록한 모든 데이터는 손실되지 않고 지속되어야 한다.</strong></p> <ul><li>지속성을 보장하기 위해서 <strong>데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.</strong></li> <li>완벽한 지속성은 보장할 수 없다. 모든 하드디스크와 백업이 동시에 파괴되면 데이터베이스가 해줄 수 있는건 없다.</li></ul> <h3 id="다중-객체-연산-트랜잭션"><a href="#다중-객체-연산-트랜잭션" class="header-anchor">#</a> 다중 객체 연산(트랜잭션)</h3> <p>다중 객체 연산을 위해서는 읽기 및 쓰기 연산들이 동일한 트랜잭션에 속하는지 알아야하고 이를 위해 관계형 데이터베이스에서는 TCP 연결 기반으로 BEGIN TRANSACTION문, COMMIT문 등을 통해 확인한다.</p> <p><strong>반면 비관계형 데이터베이스는 구현의 복잡성과 매우 높은 가용성 및 성능을 위해 이런 방식을 지원하지 않는 경우가 많다.</strong></p> <h4 id="다중-객체-트랜잭션의-필요성"><a href="#다중-객체-트랜잭션의-필요성" class="header-anchor">#</a> 다중 객체 트랜잭션의 필요성</h4> <ul><li>단일 객체 트랜잭션 만으로 충분한 사용 사례가 있지만 많은 경우에 다중 객체 트랜잭션이 필요하다.
<ol><li>서로 참조하는 여러 레코드를 삽입할 때 참조 키는 항상 올바르고 최신 정보를 반영해야 한다.</li> <li>비정규화된 여러 테이블의 데이터들을 한 번에 갱신해야 한다.</li> <li>보조 색인이 있는 경우 값이 변경될 때 색인도 함께 갱신되어야 한다.</li></ol></li></ul> <h3 id="오류와-어보트-처리"><a href="#오류와-어보트-처리" class="header-anchor">#</a> 오류와 어보트 처리</h3> <p><strong>트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.</strong></p> <p>어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지 않다.</p> <ul><li>트랜잭션이 실제론 커밋되었지만 네트워크 문제로 클라이언트는 실패했다고 생각하여 중복 처리가 될 수 있다.</li> <li>오류가 과부하 때문이라면 재시도는 더 큰 문제를 만들 수 있다.</li> <li>일시적인 오류(데드락, 네트워크 오류, 시스템 장애)에만 가치있고 영구적인 오류(제약 조건 위반)는 재시도해도 소용이 없다.</li></ul> <h2 id="완화된-격리-수준-weak-isolation-level"><a href="#완화된-격리-수준-weak-isolation-level" class="header-anchor">#</a> 완화된 격리 수준(Weak Isolation Level)</h2> <p>트랜잭션이 직렬적으로 실행되는 직렬성 격리는 성능 비용이 크기 때문에 많은 데이터베이스는 그 비용을 지불하려고 하지 않는다. 따라서 완화된 격리 수준을 사용하는 시스템들이 흔하다.</p> <p>완화된 격리 수준은 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는다. 각 수준별 특성을 파악하여 애플리케이션에 적합한 격리 수준을 선택할 수 있게 하자.</p> <h3 id="커밋-후-읽기-read-committed"><a href="#커밋-후-읽기-read-committed" class="header-anchor">#</a> 커밋 후 읽기(read committed)</h3> <p>가장 기본적인 트랜잭션 격리 수준으로 다음 두 가지를 보장해준다.</p> <ol><li>데이터베이스에서 읽을 때 커밋된 데이터만 본다.(<code>더티 읽기</code>가 없음)</li> <li>데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.(<code>더티 쓰기</code>가 없음)</li></ol> <h4 id="더티-읽기-방지"><a href="#더티-읽기-방지" class="header-anchor">#</a> 더티 읽기 방지</h4> <ul><li>다른 트랜잭션에서 커밋되지 않은 데이터를 보는 경우를 <code>더티 읽기</code>라고 부른다.</li> <li>커밋 후 읽기 격리 수준에서는 더티 읽기를 막아야 한다.</li> <li>더티 읽기를 막는게 유용한 이유는 다음과 같다.
<ul><li>트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있게 된다.</li> <li>트랜잭션이 어보트되면 롤백해야 하는데 더티 읽기가 생기면 실제로 커밋되지 않은 롤백된 데이터를 볼 수 있게 된다.</li></ul></li></ul> <h4 id="더티-쓰기-방지"><a href="#더티-쓰기-방지" class="header-anchor">#</a> 더티 쓰기 방지</h4> <ul><li>아직 커밋되지 않은 트랜잭션에서 쓴 데이터를 새로운 트랜잭션이 덮어 쓰는 경우를 <code>더티 쓰기</code>라고 한다.
<ul><li>보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두번째 쓰기를 지연시킨다.</li></ul></li> <li>커밋 후 읽기 격리 수준에서는 더티 쓰기를 막아야 한다.</li> <li>더티 쓰기를 막지 않으면 트랜잭션이 여러 객체를 갱신할 때 갱신 값들이 다른 트랜잭션과 뒤섞여 데이터에 문제가 발생할 수 있다.</li></ul> <h4 id="커밋-후-읽기-구현"><a href="#커밋-후-읽기-구현" class="header-anchor">#</a> 커밋 후 읽기 구현</h4> <ul><li>더티 쓰기의 경우 가장 흔한 방법으로 로우 수준 잠금을 사용해 방지한다.
<ul><li>트랜잭션에서 로우(객체)를 변경하고 싶다면 잠금을 획득해야 하고 오직 한 트랜잭션만 어떤 주어진 객체에 대해 잠금을 보유할 수 있다.</li></ul></li> <li>더티 읽기는 잠금을 사용하면 응답 시간에 많은 영향을 주기 때문에 <strong>데이터베이스는 모든 객체에 대해 과거에 커밋된 값과 현재 트랜잭션에서 쓴 새로운 값을 모두 기억한다.</strong> <ul><li>다른 트랜잭션은 현재 트랜잭션에서 커밋하기 전 까지는 과거에 커밋된 값을 읽게 된다.</li></ul></li></ul> <h4 id="커밋-후-읽기-에서는-막을-수-없는-비반복-읽기-non-repeatable-read"><a href="#커밋-후-읽기-에서는-막을-수-없는-비반복-읽기-non-repeatable-read" class="header-anchor">#</a> 커밋 후 읽기 에서는 막을 수 없는 비반복 읽기(non-repeatable read)</h4> <img src="/blog/assets/img/repeatable_read.08bcba7f.png"> <ul><li>Account1, 2에 각각 500원 씩 있고 Account2 -&gt; Account1로 100원을 송금(Transfer) 트랜잭션이 수행 중일 때 Alice가 계좌를 확인하는 트랜잭션을 수행하면 비반복 읽기가 발생할 수 있다.</li> <li>계좌 잔고를 확인하는 트랜잭션 내에서 Account1은 송금 트랜잭션 커밋전에 조회하여 500원을 얻고 Account2는 송금 트랜잭션이 커밋된 이후에 조회하여 400원을 얻어 100원이 사라져 버린것 처럼 보일 수 있다.</li> <li><strong><code>Read commited</code>는 다른 트랜잭션이 커밋한 데이터를 읽을 수 있기 때문에 한 트랜잭션에서 같은 데이터를 조회할 때 데이터가 달라질 수 있는 것이다. 이런 현상을 <code>Non-repeatable read</code>, <code>Read skew</code>라고 한다.</strong></li></ul> <h3 id="스냅숏-격리-snapshot-isolation"><a href="#스냅숏-격리-snapshot-isolation" class="header-anchor">#</a> 스냅숏 격리(Snapshot Isolation)</h3> <p>스냅숏 격리는 비반복 읽기와 같은 문제를 해결할 수 있는 가장 흔한 해결책이다. 트랜잭션은 특정 시점에 고정된 데이터베이스의 일관된 스냅숏만을 볼 수 있다.</p> <p><strong>각 트랜잭션은 데이터베이스의 일관된 스냅숏으로 부터 읽는다.</strong> <strong>그러므로 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 데이터만을 보게 되어 <code>Non-repeatable read</code>가 발생하지 않는다.</strong></p> <p>스냅숏 격리는 PostgreSQL, InnoDB 엔진 기반의 MySQL, Oracle 등에서 지원한다.</p> <h4 id="스냅숏-격리-구현"><a href="#스냅숏-격리-구현" class="header-anchor">#</a> 스냅숏 격리 구현</h4> <ul><li><strong>스냅숏 격리를 구현하기 위해서는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다.</strong></li> <li>데이터베이스가 객체의 <strong>여러 버전을 함께 유지하는 기법을 다중 버전 동시성 제어(multi-version concurreny control, MVCC)라고 한다.</strong> <ul><li>스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다.(커밋된 버전과 아직 커밋되지 않은 버전 2가지로 커밋 후 읽기 격리를 구현할 수 있다.)</li></ul></li> <li>트랜잭션 별로 고유한 트랜잭션 ID를 할당받고 트랜잭션이 데이터를 쓸 때 마다 해당 트랜잭션 ID와 버전별 객체가 기록되어 트랜잭션에 따라 특정 버전의 객체들을 읽을 수 있도록 한다.</li></ul> <img src="/blog/assets/img/snapshot_isolation.ba50ffee.png"> <ul><li>MVCC 기반의 스냅숏 격리를 통해 이전 예제에서 발생한 비반복 읽기 문제를 해결할 수 있다.</li> <li>트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID를 할당받고 트랜잭션이 데이터를 쓸 때마다 해당 트랜잭션의 ID를 추가한다.
<ul><li><code>creatd by</code>, <code>deleted by</code> 필드가 있고 각각 필드에 트랜잭션 ID가 설정된다. 가장 최신의 <code>deleted by</code>에는 값이 비어있게 된다.</li> <li>실제 로우를 수정/삭제하면 데이터베이스에서 지우지 않고 <code>deleted by</code> 필드를 설정하여 지워졌다고 표시한다.</li></ul></li> <li>한 트랜잭션은 자신의 트랜잭션 ID를 기반으로 트랜잭션이 시잘할 때 커밋된 데이터만을 볼 수 있다.</li> <li>삭제된 데이터에 접근하는 트랜잭션이 더 이상 존재하지 않는게 확실해지면 삭제 표시된 로우들을 삭제할 수 있다.</li></ul> <h4 id="반복-읽기-repeatable-read-스냅숏-격리"><a href="#반복-읽기-repeatable-read-스냅숏-격리" class="header-anchor">#</a> 반복 읽기(repeatable read) = 스냅숏 격리</h4> <ul><li>PostgreSQL, MySQL에서는 스냅숏 격리를 반복 읽기라고 한다.</li></ul> <h3 id="갱신-손실-lost-update-방지"><a href="#갱신-손실-lost-update-방지" class="header-anchor">#</a> 갱신 손실(Lost Update) 방지</h3> <p>커밋 후 읽기와 스냅숏 격리는 주로 동시에 실행되는 쓰기 작업에서 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 보장과 관련된 것이다.</p> <p>하지만 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌 상황들이 존재하며 가장 유명한 것이 <strong>갱신 손실(lost update) 문제이다.</strong></p> <ul><li>갱신 손실 문제는 값을 읽고 변경한 후 변경된 값을 다시 써야할 때(read-modify-write) 여러 트랜잭션이 동시에 해당 작업은 수행하는 경우 발생할 수 있다.</li> <li>이 문제는 흔해서 다양한 해결책이 개발되었다.</li></ul> <h4 id="_1-원자적-쓰기-연산"><a href="#_1-원자적-쓰기-연산" class="header-anchor">#</a> 1) 원자적 쓰기 연산</h4> <ul><li>여러 데이터베이스에서 원자적 쓰기 연산을 제공하기 때문에 애플리케이션에서 read-modify-write 주기를 구현할 필요를 없애 준다.</li> <li><code>UPDATE counters SET value = value + 1 WHERE key = 'foo'</code> 이 쿼리는 대부분의 관계형 데이터베이스에서 동시성 안전하다.</li></ul> <h4 id="_2-명시적인-잠금"><a href="#_2-명시적인-잠금" class="header-anchor">#</a> 2) 명시적인 잠금</h4> <ul><li>데이터베이스에서 원자적 쓰기 연산을 제공하지 않는다면 애플리케이션에서 객체를 명시적으로 잠그는 방식으로 해결할 수 있다.</li> <li>MySQL의 경우 SELECT 시 <code>FOR UPDATE</code> 절을 활용하여 로우를 잠글 수 있다. <strong>단, 명시적인 잠금 방식은 실수할 여지가 많다.</strong></li></ul> <h4 id="_3-갱신-손실-자동-감지"><a href="#_3-갱신-손실-자동-감지" class="header-anchor">#</a> 3) 갱신 손실 자동 감지</h4> <ul><li>병렬 실행을 허용하도록 하고 갱신 손실을 자동 감지하여 발견 시 트랜잭션을 어보트 시키고 read-modify-write 주기를 재시도 하도록 강제하는 방법이 있다.</li> <li>이 기능은 명시적인 잠금을 실수로 빼먹었을 때 자동으로 갱신 손실을 감지하여 트랜잭션을 어보트 시킬 수 있기 때문에 유용하다.</li> <li>오라클, SQL 서버는 이 기능을 제공하지만 InnoDB 기반의 MySQL은 이 기능을 제공하지 않는다.</li></ul> <h4 id="_4-compare-and-set"><a href="#_4-compare-and-set" class="header-anchor">#</a> 4) Compare-and-set</h4> <ul><li>트랜잭션을 제공하지 않는 데이터베이스 중에는 원자적 <code>compare-and-set</code> 연산을 제공한다.</li> <li>이 연산을 통해 값을 읽은 후로 변경되지 않았을 때만 갱신을 허용하여 갱신 손실을 회피할 수 있다.</li> <li>동시에 같은 데이터를 수정할 때 <code>compare-and-set</code>을 활용하면 하나의 갱신 요청만 성공하고 다른 요청은 적용되지 않을 것이다.
<ul><li><code>UPDATE item SET name = 'new name 1' WHERE id = 123 AND name = 'old name'</code></li> <li><code>UPDATE item SET name = 'new name 2' WHERE id = 123 AND name = 'old name'</code></li> <li>두 요청이 동시에 들어오면 하나만 성공할 것이고 다른 하나는 <code>WHERE</code> 조건이 맞지 않으므로 실패한다.</li> <li><strong>만약 <code>WHERE</code> 절이 최신 데이터를 읽지 못한다면 갱신 손실을 막지 못할 수도 있다.</strong></li></ul></li></ul> <h4 id="_5-충돌-해소와-복제"><a href="#_5-충돌-해소와-복제" class="header-anchor">#</a> 5) 충돌 해소와 복제</h4> <ul><li>다중 리더 복제나 리더 없는 복제를 사용하는 데이터베이스는 여러 노드에 데이터 복사본이 있고 다른 노드에서 동시에 데이터 변경이 가능하므로 갱신 손실 방지를 위해 추가 단계가 필요하다.</li> <li>카운터 증가와 같이 교환 법칙(연산의 순서가 달라져도 상관 없는)이 성립하는 원자적 연산은 복제 상황에서도 잘 동작할 수 있다.</li> <li>많은 데이터베이스에서 채택한 <code>최종 쓰기 승리(Last Wrie Wins)</code> 방식을 갱신 손실이 발생하기 쉽다. (<a href="https://pompitzz.github.io/blog/ComputerScience/DesigningDataIntensiveApplication/ch5.html#%E1%84%83%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5-%E1%84%8A%E1%85%B3%E1%84%80%E1%85%B5-%E1%84%80%E1%85%A1%E1%86%B7%E1%84%8C%E1%85%B5" target="_blank" rel="noopener noreferrer">ch5 참고<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</li></ul> <h3 id="쓰기-스큐-write-skew-와-팬텀"><a href="#쓰기-스큐-write-skew-와-팬텀" class="header-anchor">#</a> 쓰기 스큐(write skew)와 팬텀</h3> <p>쓰기 스큐는 동시에 실행되는 두 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신하는데 각각 다른 객체들을 갱신하여 애플리케이션의 요구사항을 위반하게 되는 현상이다.</p> <ul><li>하나의 동일한 객체를 갱신하는 경우에는 <code>더티 쓰기</code>, <code>갱신 손실</code> 현상을 겪을 수 있다.</li></ul> <h4 id="쓰기-스큐-예시"><a href="#쓰기-스큐-예시" class="header-anchor">#</a> 쓰기 스큐 예시</h4> <img src="/blog/assets/img/write-skew.fb7f7b13.png"> <ul><li>의사들의 호출 대기를 관리하는 애플리케이션이 있다.</li> <li>Alice와 Bob이 호출 대기를 하고 있을 때 둘 다 호출 대기를 그만두려고 하는데 동시에 호출 대기 상태를 끄게 되는 케이스에 쓰기 스큐가 발생할 수 있다.</li> <li>각 트랜잭션의 첫 번째 쿼리에서 현재 호출 대기 중인 의사의 수를 확인한다.</li> <li>데이터베이스에서 스냅숏 격리를 사용하고 있다면 둘 다 <code>2</code>를 반환하게 되므로 각각의 <code>on_call</code> 상태를 <code>false</code>로 변경되고 트랜잭션은 커밋된다.</li> <li><strong>이로 인해 호출 대기하는 의사가 한 명도 없게된다. 최소 한 명의 의사가 호출 대기해야 하는 요구사항을 위반했다.</strong></li> <li>이 케이스의 경우 <code>SELECT</code> 절에 <code>FOR UPDATE</code>를 붙여 로우를 명시적으로 잠그면 해결할 수 있다.</li></ul> <h4 id="쓰기-스큐-패턴"><a href="#쓰기-스큐-패턴" class="header-anchor">#</a> 쓰기 스큐 패턴</h4> <ul><li>쓰기 스큐가 발생하는 케이스들은 비슷한 패턴을 따른다.</li></ul> <ol><li><code>SELECT</code> 질의가 어떤 조건에 부합하는 로우를 검색하여 요구사항을 만족하는지 확인한다.</li> <li>첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할 지 결정된다.</li> <li>계속 진행하는 것으로 결졍되었다면 데이터베이스에 쓰고 트랜잭션이 커밋된다. <strong>이 쓰기의 효과로 2단계에 결정한 전제 조건이 변경된다.</strong> <ul><li>호출 대기 예시에서는 3단계에서 변경되는 로우가 1단계에서 반환되는 로우 중 하나였다. 그래서 1단계에 잠금(SELECT FOR UPDATE)을 걸어 쓰기 스큐를 회피할 수 있다.</li> <li><strong>하지만 1단계 질의가 아무 로우도 반환하지 않아 잠금으로 해결할 수 없는 예시들이 존재한다.</strong></li></ul></li></ol> <ul><li><strong>이 패턴은 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸게 되는데 이런 효과를 <code>팬텀(phantom)</code>이라고 한다.</strong> <ul><li>스냅숏 격리는 읽기 전용 질의에서는 팬텀을 회피하지만 읽기 쓰기 트랜잭션에서는 팬텀이 쓰기 스큐를 유발할 수 있다.</li></ul></li></ul> <h4 id="잠금으로-해결할-수-없는-쓰기-스큐-예시"><a href="#잠금으로-해결할-수-없는-쓰기-스큐-예시" class="header-anchor">#</a> 잠금으로 해결할 수 없는 쓰기 스큐 예시</h4> <ul><li>회의실 예약 시스템
<ul><li>회의실 예약 시스템은 중복된 예약을 방지해야 한다.</li> <li>중복된 예약 방지를 위해선 예약 전 해당 시간대에 잡힌 예약이 있는지 확인해야 한다.</li> <li>잡힌 예약이 없다는 아무 로우도 반환되지 않으므로 해당 로우를 잠글 수 없다.</li></ul></li> <li>잠금이 불가능한 경우 인위적으로 데이터베이스에 잠금 객체를 추가하여 팬텀을 잠금 충돌의 문제로 변환시키는 <code>충돌 구체화</code> 전략이 있다.
<ul><li>이 방법은 구체화하는 방법을 찾기 어렵고 오류가 발생하기 쉬우므로 최후의 수단으로 고려해야 한다.</li> <li><strong>대부분의 경우 직렬성 격리 수준으로 해결하는 것이 선호된다.</strong></li></ul></li></ul> <h2 id="직렬성-serializability"><a href="#직렬성-serializability" class="header-anchor">#</a> 직렬성(Serializability)</h2> <p><strong>직렬성 격리는 여러 트랜잭션이 병렬로 실행되더라도 결과는 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.</strong></p> <p>직렬성을 제공하는 데이터베이스는 대부분 세 가지 기법 중 하나를 사용한다.</p> <ul><li>트랜잭션 직렬 실행</li> <li>2단계 잠금</li> <li>직렬성 스냅숏 격리(Serializable Snapshot Isolation)</li></ul> <h3 id="_1-트랜잭션-직렬-실행"><a href="#_1-트랜잭션-직렬-실행" class="header-anchor">#</a> 1. 트랜잭션 직렬 실행</h3> <ul><li>동시성 문제를 회피하기 위한 가장 간단한 방법은 실제로 동시성을 완전히 제거하는 것이다. 한 번에 트랜잭션이 하나씩만 실행되도록 <code>단일 스레드</code>에서 실행하면 된다.</li> <li><strong>트랜잭션 직렬 실행은 몇 가지 제약 사항 안에서 직렬성 격리를 획득하는 실용적인 방법이다.</strong> <ul><li>모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 모든 트랜잭션 처리를 지연시킬 수 있다.</li> <li>활성화된 데이터셋을 메모리에 적재할 수 있어야 한다. 단일 스레드 트랜잭션에서 디스크에 접근하면 시스템은 매우 느려진다.</li> <li>쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도여야 한다. 파티셔닝이 가능하지만 어느정도의 제한이 있다.</li></ul></li> <li>하드웨어 성능이 올라가 인메모리 데이터베이스 구현이 가능해졌고 OLTP 트랜잭션의 특성 상 쓰기 읽기 트랜잭션 시간이 짧고 로우 개수가 적기 때문에 단일 스레드 기반의 데이터베이스가 실현 가능해졌다.(<a href="https://pompitzz.github.io/blog/ComputerScience/DesigningDataIntensiveApplication/ch3.html#oltp%E1%84%8B%E1%85%AA-olap-%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5-%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%92%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%89%E1%85%B3" target="_blank" rel="noopener noreferrer">참고<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</li> <li>단일 스레드 시스템은 오버헤드를 피할 수 있으므로 동시성을 지원하는 시스템보다 성능이 나을 떄도 있다. <strong>하지만 처리량이 CPU 코어 하나의 처리량으로 제한되는 단점이 존재한다.</strong></li> <li><strong>단일 스레드를 활용하기 위해서는 트랜잭션이 전통적인 현태와는 다르게 구조화 되어야 한다.</strong> <ul><li>단일 스레드 시스템에서 기존 RDB의 상호작용식 트랜잭션을 사용하면 처리량이 매우 좋지 않을 것이다.</li></ul></li> <li>트랜잭션 코드 전체를 <code>스토어드 프로시저(stored procedure)</code> 형태로 데이터베이스에 제출하는 방식을 사용한다.
<ul><li><strong>스토어드 프로시저를 사용하면 I/O 대기가 필요 없어 지므로 단일 스레드에서 좋은 처리량을 얻을 수 있다.</strong></li> <li>하지만 프로시저 코드를 관리하기 어렵고 애플리케이션에서 디버깅이 어려우며 프로시저를 잘못 작성하여 데이터베이스 성능에 영향을 줄 수 있다.</li></ul></li> <li><strong>단일 스레드 시스템의 처리량을 높이기 위해 파티셔닝 기법을 활용하면 된다.</strong>(<a href="https://pompitzz.github.io/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html#%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%84%82%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A6" target="_blank" rel="noopener noreferrer">참고<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)
<ul><li>파티셔닝을 하는 경우 여러 파티션에 접근해야 하는 트랜잭션을 어떻게 처리할 지 고민이 필요하다.</li> <li>여러 파티션에 걸친 트랜잭션은 잠금이 필요하므로 오버헤드가 있어 상당히 느릴 수 있다.</li> <li>트랜잭션을 한 파티션에서 처리할 수 있도록 설계하는게 좋을 것이다.</li></ul></li></ul> <h3 id="_2-2단계-잠금-2pl"><a href="#_2-2단계-잠금-2pl" class="header-anchor">#</a> 2. 2단계 잠금(2PL)</h3> <ul><li>데이터베이스에서 직렬성 구현을 위해 가장 많이 쓰인 알고리즘이 2단계 잠금(2-phase locking)이다.
<ul><li><strong>2단계 잠금(2PL)과 2단계 커밋2PC(2PC)는 비슷하지만 완전히 다르다.</strong>(<a href="https://pompitzz.github.io/blog/ComputerScience/DesigningDataIntensiveApplication/ch9.html#%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8C%E1%85%A5%E1%86%A8-%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B5%E1%86%BA%E1%84%80%E1%85%AA-2%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8-%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B5%E1%86%BA-2pc" target="_blank" rel="noopener noreferrer">2PC 참고<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</li></ul></li> <li>2PL은 쓰기 트랜잭션이 다른 쓰기 트랜잭션 뿐만아니라 읽기 트랜잭션도 진행하지 못하게 막는다.
<ul><li>트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체를 쓰려고한다면 A가 커밋되거나 어보트될 때 까지 기다려야 한다. (B가 A몰래 객체를 변경하지 못하도록 보장한다.)</li> <li>트랜잭션 A가 객체에 썼고 트랜잭션 B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때 까지 기다려야 한다. (B가 과거 데이터를 읽지 않도록 보장한다.)</li></ul></li> <li><strong>잠금 획득 오버헤드 뿐만 아니라 동시성이 줄어들기 때문에 다른 격리 수준에 비해 성능이 크게 나쁘다. 트랜잭션이 길수록 성능은 더 나빠진다.</strong></li></ul> <h4 id="_2단계-잠금-구현"><a href="#_2단계-잠금-구현" class="header-anchor">#</a> 2단계 잠금 구현</h4> <ul><li>MySQL(InnoDB)는 직렬성 격리 수준 구현을 위해 2PL을 사용한다.</li> <li>데이터베이스의 각 객체에 잠금을 사용해 구현하고 잠금을 <code>공유 모드(shared mode)</code>와 <code>독점 모드(exclusive mode)</code>로 구분한다.
<ul><li>트랜잭션이 객체를 읽으려고 하면 먼저 <code>공유 모드</code>로 잠금을 획득해야 한다.
<ul><li>여러 트랜잭션이 <code>공유 모드</code> 잠금을 획득하는건 가능하나 이미 그 객체에 <code>독점 모드</code> 잠금을 획득한 트랜잭션이 있으면 해당 트랜잭션 완료까지 기다려야 한다.</li></ul></li> <li>트랜잭션이 객체에 쓰기를 원한다면 먼저 <code>독점 모드</code>로 잠금을 획득해야 한다.
<ul><li><code>공유 혹은 독점 모드</code> 잠금이 이미 있으면 다른 어떤 트랜잭션도 잠금을 획득할 수 없고 기다려야 한다.</li></ul></li> <li>트랜잭션이 객체를 읽다가 쓰려고 하면 <code>공유 모드</code>를 <code>독점 모드</code> 잠금으로 업그레이드 해야 한다.
<ul><li><code>독점 모드</code> 잠금을 획득하는 과정과 동일하게 이루어진다.</li></ul></li> <li>트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될 때 까지 잠금을 갖고 있어야 한다.</li></ul></li> <li>2PL은 잠금이 많이 사용되므로 데드락이 발생할 가능성이 높아 데이터베이스는 데드락 감지를 통해 트랜잭션 중 하나를 어보트 시킬 수 있다.</li></ul> <h4 id="서술-잠금-predicate-lock-과-색인-범위-잠금-index-range-lock"><a href="#서술-잠금-predicate-lock-과-색인-범위-잠금-index-range-lock" class="header-anchor">#</a> 서술 잠금(Predicate lock)과 색인 범위 잠금(Index-range lock)</h4> <ul><li>회의실 예약 시스템 예시처럼 잠글 수 있는 객체가 없는 경우의 쓰기 스큐를 방지하기 위해선 <code>서술 잠금</code>이 필요하다.</li> <li><code>서술 잠금</code>은 특정 객체에 속하지 않고 어떤 검색 조건에 부합하는 모든 객체를 잠글 수 있다.
<ul><li>트랜잭션 A가 <code>SELECT</code> 질의의 어떤 조건에 부합하는 객체를 읽을 때 <code>공유 모드 서술 잠금</code>을 획득해야 한다. 다른 트랜잭션이 <code>독점 잠금</code>을 가지고 있다면 기다려야 한다.</li> <li>트랜잭션 A가 어떤 객체들을 쓰려고 할 때 해당 객체들에 <code>서술 잠금</code>에 부합하는게 있는지 확인해야 한다. <code>서술 잠금</code>을 다른 트랜잭션이 잡고 있다면 기다려야 한다.</li></ul></li> <li><strong>2단계 잠금이 서술 잠금 까지 포함하면 모든 형태의 쓰기 스큐를 막을 수 있고 격리 수준이 직렬성 격리가 된다.</strong></li> <li><strong>하지만 서술 잠금은 성능이 좋지 않아 대부분 2PL을 지원하는 데이터베이스는 서술 잠금을 간략하게 근사한 <code>색인 범위 잠금</code>을 구현한다.</strong> <ul><li>색인 범위 잠금은 더 많은 객체가 부합되도록 서술 조건을 간략화하여 잠금을 수행한다.</li> <li>오후 1~2시에 1번 방을 예약하는 것에 대한 서술 잠금은 모든 시간 범위에 1번방을 예약하는 것에 대한 잠금으로 근사할 수 있다.</li> <li><strong>이때 방 번호에 대한 색인이 필요하다.</strong> 시간에 대해 색인이 있다면 시간으로 근사할 수 있을 것이다.</li></ul></li> <li><code>색인 범위 잠금</code>은 <code>서술 잠금</code>보다 정밀하지 않지만 오버헤드가 훨씬 더 낮기 때문에 좋은 타협안이 된다.</li></ul> <h3 id="_3-직렬성-스냅숏-격리-serializable-snapshot-isolation"><a href="#_3-직렬성-스냅숏-격리-serializable-snapshot-isolation" class="header-anchor">#</a> 3. 직렬성 스냅숏 격리(Serializable Snapshot Isolation)</h3> <ul><li>직렬성 격리 수준의 가장 큰 단점은 성능이다. 이 문제를 해결하기 위해 직렬성 스냅숏 격리가 유망하다.</li> <li>2단계 잠금은 <code>비관적</code> 동시성 제어 기법이지만 직렬성 스냅숏 격리는 <code>낙관적</code> 동시성 제어 기법이다.</li> <li>트랜잭션이 커밋되기를 원할 때 데이터베이스는 격리가 위반됐는지 확인하여 직렬성 격리 수준을 제공할 수 있다.</li> <li><strong>직렬성 스냅숏 격리는 경쟁이 심하면 어보트시켜야 할 트랜잭션이 늘어나므로 성능이 떨어진다. 하지만 경쟁이 심하지 않다면 비관적 방식보다 성능이 더 뛰어나다.</strong></li> <li>직렬성 스냅숏 격리는 스냅숏 격리를 기반으로 하기 때문에 <strong>모든 읽기는 데이터베이스의 일관된 스냅숏을 본다.</strong> <ul><li>스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하여 어보트시킬 트랜잭션을 결정하는 알고리즘이 추가된다.</li></ul></li> <li>직렬성 충돌을 방지하기 위해 고려해야 하는 케이스는 두 가지가 있다.</li></ul> <h4 id="_1-오래된-mvcc-읽기-감지"><a href="#_1-오래된-mvcc-읽기-감지" class="header-anchor">#</a> 1) 오래된 MVCC 읽기 감지</h4> <ul><li>스냅숏 격리는 트랜잭션이 시작될 때 MVCC의 일관된 스냅숏을 기반으로 데이터를 읽기 때문에 다른 트랜잭션에서 커밋되지 않은 쓰기는 무시된다.</li> <li>트랜잭션이 객체를 조회할 때 오래된 MVCC 객체를 읽었는지 감지한다. 감지된게 있다면 트랜잭션을 커밋할 때 데이터베이스는 해당 트랜잭션을 어보트시켜야 한다.
<ul><li>읽는 즉시 어보트하지 않고 커밋 시점에 하는 이유는 읽기 전용 트랜잭션이라면 쓰기 스큐의 위험이 없기 때문이다.</li></ul></li></ul> <img src="/blog/assets/img/detecting-MVCC.fae1fbf0.png"> <ul><li>트랜잭션 43이 <code>SELECT</code> 쿼리를 호출할 때 트랜잭션 42에 쓰기가 수행되었으므로 오래된 MVCC 객체를 읽을 것으로 본다.</li> <li>트랜잭션 43이 커밋하려고 할 때 트랜잭션 42는 커밋된 상태이므로 오래된 MVCC 객체를 읽은게 확실해졌으므로 트랜잭션을 어보트 시킨다.</li></ul> <h4 id="_2-과거에-읽기에-영향을-미치는-쓰기-감지"><a href="#_2-과거에-읽기에-영향을-미치는-쓰기-감지" class="header-anchor">#</a> 2) 과거에 읽기에 영향을 미치는 쓰기 감지</h4> <ul><li>트랜잭션이 객체를 읽은 후에 다른 트랜잭션에서 해당 객체를 썼는지를 감지한다. 감지된게 있다면 트랜잭션을 커밋할 때 데이터베이스는 해당 트랜잭션을 어보트시켜야 한다.</li></ul> <img src="/blog/assets/img/detecting-modification.c642ef40.png"> <ul><li>트랜잭션 42, 43에서 <code>SELECT</code> 쿼리를 호출할 때 색인 범위 잠금 기법을 통해 트랜잭션 42, 43이 객체를 읽었다는 사실을 기록한다.
<ul><li>해당 색인 잠금은 2단계 잠금과 다르게 트랜잭션을 차단하지 않는다.</li></ul></li> <li>트랜잭션 42가 객체를 쓸 때 해당 객체를 최근에 읽은 트랜잭션이 있는지를 색인 범위 잠금에서 확인한다. 그리고 각 트랜잭션에게 해당 데이터가 더 이상 최신이 아니라고 알려준다.</li> <li>트랜잭션 42가 먼저 커밋을 시도해 성공하였으므로 트랜잭션 43이 커밋을 하려고하면 해당 트랜잭션을 어보트 시킨다.</li></ul> <h4 id="직렬성-스냅숏-격리의-성능"><a href="#직렬성-스냅숏-격리의-성능" class="header-anchor">#</a> 직렬성 스냅숏 격리의 성능</h4> <ul><li>2단계 잠금과 비교하여 트랜잭션이 다른 트랜잭션을 기다리느라 차단되지 않기 때문에 읽기 작업이 많은 경우 성능이 더 뛰어나다.</li> <li>트랜잭션의 읽기 쓰기를 추적하는 세밀함에 따라 기록 오버헤드가 달라진다. 덜 상세하게 추적하면 오버헤드가 작아 속도는 빠르겠지만 많은 트랜잭션이 어보트될 수 있다.</li> <li>어보트 비율은 성능에 큰 영향을 미친다. 오랫동안 데이터를 읽고 쓰는 트랜잭션은 충돌 가능성이 높아 어보트되기 쉬우므로 읽기-쓰기 트랜잭션이 짧을 수록 유리하다.(읽기 전용 트랜잭션은 문제 없다.)</li></ul> <h2 id="정리"><a href="#정리" class="header-anchor">#</a> 정리</h2> <p>트랜잭션이 없으면 다양한 오류 시나리오에서 다양한 방법으로 일관성이 깨질 수 있다. 비정규화된 데이터는 원천 데이터와 동기화가 깨지기 쉬우나 트랜잭션이 있다면 원자적으로 동작하여 동기화를 이룰 수 있다.</p> <h3 id="acid-2"><a href="#acid-2" class="header-anchor">#</a> ACID</h3> <ul><li><strong>원자성(Atomicity)</strong> <ul><li>한 트랜잭션에서 발생한 쓰기들은 모두 <code>완료(커밋)</code>되거나 결함 발생 시 모두 <code>중단(어보트)</code>되거나 둘 중 하나여야 한다.</li></ul></li> <li><strong>일관성(Consistency)</strong> <ul><li>트랜잭션이 완료될 때 데이터에 관한 <code>불변식</code>이 반드시 만족되어야 한다.</li></ul></li> <li><strong>격리성(Isolation)</strong> <ul><li>동시에 실행되는 트랜잭션은 서로 격리되어야 한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다.</li></ul></li> <li><strong>지속성(Durability)</strong> <ul><li>트랜잭션이 성공적으로 커밋됐다면 트랜잭션에서 기록한 모든 데이터는 손실되지 않고 지속되어야 한다.</li></ul></li></ul> <h3 id="격리-수준"><a href="#격리-수준" class="header-anchor">#</a> 격리 수준</h3> <ul><li><strong>커밋 후 읽기(read commited)</strong></li> <li><strong>스냅숏 격리(snapshot isolation)=반복 읽기(repeatable read)</strong></li> <li><strong>직렬성 격리(serializable)</strong></li></ul> <h3 id="경쟁-조건-race-condition"><a href="#경쟁-조건-race-condition" class="header-anchor">#</a> 경쟁 조건(Race Condition)</h3> <ul><li><strong>더티 읽기</strong> <ul><li>다른 트랜잭션에서 썼으나 커밋되지 않은 데이터를 읽는다. 커밋 후 읽기와 그 보다 높은 격리 수준은 더티 읽기를 방지한다.</li></ul></li> <li><strong>더티 쓰기</strong> <ul><li>다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터를 덮어쓴다. 거의 모든 트랜잭션 구현은 더티 쓰기를 방지한다. 로우 수준 잠금이 가장 흔한 구현 방식이다.</li></ul></li> <li><strong>읽기 스큐(비반복 읽기)</strong> <ul><li>한 트랜잭션에서 같은 데이터를 여러번 조회할 때 다른 트랜잭션의 쓰기로 인해 결과가 달라진다. 보통 스냅숏 격리를 통해 방지한다. 스냅숏 격리는 주로 다중 버전 동시성 제어(MVCC)를 써서 구현한다.</li></ul></li> <li><strong>갱신 손실</strong> <ul><li>두 트랜잭션이 동시에 읽기-수정-쓰기(read-modify-write)를 수행할 때 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은채로 덮어써서 데이터가 손실된다.</li> <li>이를 자동으로 감지하고 막아주는 데이터베이스가 있지만 그렇지 않다면 명시적인 잠금이나 방지 가능한 연산을 활용해야 한다.</li></ul></li> <li><strong>쓰기 스큐</strong> <ul><li>동시에 실행되는 두 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신하는데 각각 다른 객체들을 갱신하여 애플리케이션의 요구사항을 위반한다.</li> <li>직렬성 격리만이 이런 현상을 막을 수 있다.</li></ul></li> <li><strong>팬텀 읽기</strong> <ul><li>트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다. 다른 트랜잭션이 그 검색 결과에 영향을 주는 쓰기를 실행하여 결과가 달라진다.</li> <li>스냅숏 격리는 간단한 팬텀 읽기는 막아주지만 쓰기 스큐 맥락에서 발생하는 팬텀은 색인 범위 잠금과 같은 특별한 처리가 필요하다.</li></ul></li></ul> <h3 id="직렬성-격리-구현"><a href="#직렬성-격리-구현" class="header-anchor">#</a> 직렬성 격리 구현</h3> <ul><li><strong>트랜잭션 직렬 실행</strong> <ul><li>단일 스레드에서 트랜잭션을 순서대로 실행한다.</li> <li>트랜잭션 실행 시간이 아주 짧고 처리량이 단일 CPU 코어에서 처리할 수 있을 정도면 효과적인 선택이다.</li></ul></li> <li><strong>2단계 잠금</strong> <ul><li>2단계 잠금 기법으로 다른 트랜잭션 진행을 막는다. 주로 사용되던 방식이지만 성능 특성 때문에 선호되지 않는다.</li></ul></li> <li><strong>직렬성 스냅숏 격리</strong> <ul><li>낙관적 방법을 사용하여 트랜잭션을 차단하지 않고 트랜잭션 커밋 시 충돌을 확인하여 충돌 시 트랜잭션을 어보트 시킨다.</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch6.html" class="prev">
        Ch 6. 파티셔닝
      </a></span> <span class="next"><a href="/blog/ComputerScience/DesigningDataIntensiveApplication/ch8.html">
        Ch 8. 분산 시스템의 골칫거리
      </a>
      →
    </span></p></div> <div data-v-0eb52d94 data-v-fa8c0460></div></main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.6f1e1328.js" defer></script><script src="/blog/assets/js/19.fd0cc71e.js" defer></script><script src="/blog/assets/js/2.771035c7.js" defer></script><script src="/blog/assets/js/3.b0b2c100.js" defer></script><script src="/blog/assets/js/1.b0de5fa9.js" defer></script><script src="/blog/assets/js/18.586c6123.js" defer></script>
  </body>
</html>
